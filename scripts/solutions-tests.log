---> Executing 'arellano_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:42:10 PM INFO: Reading notebook arellano_solutions.ipynb
09/11/2015 03:42:11 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:42:12 PM INFO: Cell returned
09/11/2015 03:42:12 PM INFO: Running cell:
from __future__ import division
import numpy as np
import matplotlib.pyplot as plt
import quantecon as qe
from quantecon.models import Arellano_Economy

09/11/2015 03:42:15 PM INFO: Cell returned
09/11/2015 03:42:15 PM INFO: Running cell:
ae = Arellano_Economy(beta=.953,        # time discount rate
                        gamma=2.,       # risk aversion
                        r=0.017,        # international interest rate
                        rho=.945,       # persistence in output 
                        eta=0.025,      # st dev of output shock
                        theta=0.282,    # prob of regaining access 
                        ny=21,          # number of points in y grid
                        nB=251,         # number of points in B grid
                        tol=1e-8,       # error tolerance in iteration
                        maxit=10000)

09/11/2015 03:42:30 PM INFO: Cell returned
09/11/2015 03:42:30 PM INFO: Running cell:

# Create "Y High" and "Y Low" values as 5% devs from mean
high, low = np.mean(ae.ygrid)*1.05, np.mean(ae.ygrid)*.95
iy_high, iy_low = (np.searchsorted(ae.ygrid, x) for x in (high, low))

fig, ax = plt.subplots(figsize=(10, 6.5))
ax.set_title("Bond price schedule $q(y, B')$")

# Extract a suitable plot grid
x = []
q_low = []
q_high = []
for i in range(ae.nB):
    b = ae.Bgrid[i]
    if -0.35 <= b <= 0:  # To match fig 3 of Arellano
        x.append(b)
        q_low.append(ae.Q[iy_low, i])
        q_high.append(ae.Q[iy_high, i])
ax.plot(x, q_high, label=r"$y_H$", lw=2, alpha=0.7)
ax.plot(x, q_low, label=r"$y_L$", lw=2, alpha=0.7)
ax.set_xlabel(r"$B'$")
ax.legend(loc='upper left', frameon=False)
plt.show()

09/11/2015 03:42:31 PM INFO: Cell returned
09/11/2015 03:42:31 PM INFO: Running cell:

# Create "Y High" and "Y Low" values as 5% devs from mean
high, low = np.mean(ae.ygrid)*1.05, np.mean(ae.ygrid)*.95
iy_high, iy_low = (np.searchsorted(ae.ygrid, x) for x in (high, low))

fig, ax = plt.subplots(figsize=(10, 6.5))
ax.set_title("Value Functions")
ax.plot(ae.Bgrid, ae.V[iy_high], label=r"$y_H$", lw=2, alpha=0.7)
ax.plot(ae.Bgrid, ae.V[iy_low], label=r"$y_L$", lw=2, alpha=0.7)
ax.legend(loc='upper left')
ax.set_xlabel(r"$B$")
ax.set_ylabel(r"$V(y, B)$")
ax.set_xlim(ae.Bgrid.min(), ae.Bgrid.max())
plt.show()

09/11/2015 03:42:32 PM INFO: Cell returned
09/11/2015 03:42:32 PM INFO: Running cell:

xx, yy = ae.Bgrid, ae.ygrid
zz = ae.default_prob

# Create figure
fig, ax = plt.subplots(figsize=(10, 6.5))
fig.suptitle("Probability of Default")
hm = ax.pcolormesh(xx, yy, zz)
cax = fig.add_axes([.92, .1, .02, .8])
fig.colorbar(hm, cax=cax)
ax.axis([xx.min(), 0.05, yy.min(), yy.max()])
ax.set_xlabel(r"$B'$")
ax.set_ylabel(r"$y$")
plt.show()

09/11/2015 03:42:32 PM INFO: Cell returned
09/11/2015 03:42:32 PM INFO: Running cell:
T = 250
y_vec, B_vec, q_vec, default_vec = ae.simulate(T)

# Pick up default start and end dates
start_end_pairs = []
i = 0
while i < len(default_vec):
    if default_vec[i] == 0:
        i += 1
    else:
        # If we get to here we're in default
        start_default = i
        while i < len(default_vec) and default_vec[i] == 1:
            i += 1
        end_default = i - 1
        start_end_pairs.append((start_default, end_default))
    
plot_series = y_vec, B_vec, q_vec
titles = 'output', 'foreign assets', 'bond price'

fig, axes = plt.subplots(len(plot_series), 1, figsize=(10, 12))
p_args = {'lw': 2, 'alpha': 0.7}
fig.subplots_adjust(hspace=0.3)

for ax, series, title in zip(axes, plot_series, titles):
    # determine suitable y limits
    s_max, s_min = max(series), min(series)
    s_range = s_max - s_min
    y_max = s_max + s_range * 0.1
    y_min = s_min - s_range * 0.1
    ax.set_ylim(y_min, y_max)
    for pair in start_end_pairs:
        ax.fill_between(pair, (y_min, y_min), (y_max, y_max), color='k', alpha=0.3)
        
    ax.grid()
    ax.set_title(title)
    ax.plot(range(T), series, **p_args)
    ax.set_xlabel(r"time")

plt.show()

09/11/2015 03:42:34 PM INFO: Cell returned
09/11/2015 03:42:34 PM INFO: Running cell:


09/11/2015 03:42:34 PM INFO: Cell returned
09/11/2015 03:42:34 PM INFO: Shutdown kernel
---> END 'arellano_solutions.ipynb' <---

---> Executing 'asset_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:42:35 PM INFO: Reading notebook asset_solutions.ipynb
09/11/2015 03:42:36 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:42:36 PM INFO: Cell returned
09/11/2015 03:42:36 PM INFO: Running cell:
from __future__ import division  # Omit for Python 3.x
import numpy as np
import matplotlib.pyplot as plt
from quantecon.models import AssetPrices

09/11/2015 03:42:38 PM INFO: Cell returned
09/11/2015 03:42:38 PM INFO: Running cell:
# == Define primitives == #
n = 5
P = 0.0125 * np.ones((n, n))
P += np.diag(0.95 - 0.0125 * np.ones(5))
s = np.array([1.05, 1.025, 1.0, 0.975, 0.95])
gamma = 2.0
beta = 0.94
zeta = 1.0

ap = AssetPrices(beta, P, s, gamma)

v = ap.tree_price()
print("Lucas Tree Prices: ", v)

v_consol = ap.consol_price(zeta)
print("Consol Bond Prices: ", v_consol)

P_tilde = P * s**(1-gamma)
temp = beta * P_tilde.dot(v) + beta * P_tilde.dot(np.ones(n))
print("Should be 0: ",  v - temp)

p_s = 150.0
w_bar, w_bars = ap.call_option(zeta, p_s, T = [10,20,30])


09/11/2015 03:42:38 PM INFO: Cell returned
09/11/2015 03:42:38 PM INFO: Running cell:


09/11/2015 03:42:38 PM INFO: Cell returned
09/11/2015 03:42:38 PM INFO: Shutdown kernel
---> END 'asset_solutions.ipynb' <---

---> Executing 'career_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:42:39 PM INFO: Reading notebook career_solutions.ipynb
09/11/2015 03:42:40 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:42:40 PM INFO: Cell returned
09/11/2015 03:42:40 PM INFO: Running cell:
import numpy as np
import matplotlib.pyplot as plt
from quantecon import DiscreteRV, compute_fixed_point
from quantecon.models import CareerWorkerProblem

09/11/2015 03:42:42 PM INFO: Cell returned
09/11/2015 03:42:42 PM INFO: Running cell:
wp = CareerWorkerProblem()
v_init = np.ones((wp.N, wp.N))*100
v = compute_fixed_point(wp.bellman_operator, v_init, verbose=False)
optimal_policy = wp.get_greedy(v)
F = DiscreteRV(wp.F_probs)
G = DiscreteRV(wp.G_probs)

def gen_path(T=20):
    i = j = 0  
    theta_index = []
    epsilon_index = []
    for t in range(T):
        if optimal_policy[i, j] == 1:    # Stay put
            pass
        elif optimal_policy[i, j] == 2:  # New job
            j = int(G.draw())
        else:                            # New life
            i, j  = int(F.draw()), int(G.draw())
        theta_index.append(i)
        epsilon_index.append(j)
    return wp.theta[theta_index], wp.epsilon[epsilon_index]

theta_path, epsilon_path = gen_path()

fig, axes = plt.subplots(2, 1, figsize=(10, 8))
for ax in axes:
    ax.plot(epsilon_path, label='epsilon')
    ax.plot(theta_path, label='theta')
    ax.legend(loc='lower right')

plt.show()



09/11/2015 03:42:45 PM INFO: Cell returned
09/11/2015 03:42:45 PM INFO: Running cell:

wp = CareerWorkerProblem()
v_init = np.ones((wp.N, wp.N))*100
v = compute_fixed_point(wp.bellman_operator, v_init)
optimal_policy = wp.get_greedy(v)
F = DiscreteRV(wp.F_probs)
G = DiscreteRV(wp.G_probs)

def gen_first_passage_time():
    t = 0
    i = j = 0
    while 1:
        if optimal_policy[i, j] == 1:    # Stay put
            return t
        elif optimal_policy[i, j] == 2:  # New job
            j = int(G.draw())
        else:                            # New life
            i, j  = int(F.draw()), int(G.draw())
        t += 1

M = 25000 # Number of samples
samples = np.empty(M)
for i in range(M): 
    samples[i] = gen_first_passage_time()
print(np.median(samples))


09/11/2015 03:42:53 PM INFO: Cell returned
09/11/2015 03:42:53 PM INFO: Running cell:
from matplotlib import cm

wp = CareerWorkerProblem()
v_init = np.ones((wp.N, wp.N))*100
v = compute_fixed_point(wp.bellman_operator, v_init)
optimal_policy = wp.get_greedy(v)

fig, ax = plt.subplots(figsize=(6,6))
tg, eg = np.meshgrid(wp.theta, wp.epsilon)
lvls=(0.5, 1.5, 2.5, 3.5)
ax.contourf(tg, eg, optimal_policy.T, levels=lvls, cmap=cm.winter, alpha=0.5)
ax.contour(tg, eg, optimal_policy.T, colors='k', levels=lvls, linewidths=2)
ax.set_xlabel('theta', fontsize=14)
ax.set_ylabel('epsilon', fontsize=14)
ax.text(1.8, 2.5, 'new life', fontsize=14)
ax.text(4.5, 2.5, 'new job', fontsize=14, rotation='vertical')
ax.text(4.0, 4.5, 'stay put', fontsize=14)



09/11/2015 03:42:57 PM INFO: Cell returned
09/11/2015 03:42:57 PM INFO: Shutdown kernel
---> END 'career_solutions.ipynb' <---

---> Executing 'estspec_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:42:59 PM INFO: Reading notebook estspec_solutions.ipynb
09/11/2015 03:43:00 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:43:00 PM INFO: Cell returned
09/11/2015 03:43:00 PM INFO: Running cell:
import numpy as np
import matplotlib.pyplot as plt
from quantecon import ARMA, periodogram, ar_periodogram

09/11/2015 03:43:02 PM INFO: Cell returned
09/11/2015 03:43:02 PM INFO: Running cell:

## Data
n = 400
phi = 0.5
theta = 0, -0.8
lp = ARMA(phi, theta)
X = lp.simulation(ts_length=n)

fig, ax = plt.subplots(3, 1, figsize=(10, 12))

for i, wl in enumerate((15, 55, 175)):  # window lengths
    
    x, y = periodogram(X)
    ax[i].plot(x, y, 'b-', lw=2, alpha=0.5, label='periodogram')

    x_sd, y_sd = lp.spectral_density(two_pi=False, res=120)
    ax[i].plot(x_sd, y_sd, 'r-', lw=2, alpha=0.8, label='spectral density')

    x, y_smoothed = periodogram(X, window='hamming', window_len=wl)
    ax[i].plot(x, y_smoothed, 'k-', lw=2, label='smoothed periodogram')

    ax[i].legend()
    ax[i].set_title('window length = {}'.format(wl))


09/11/2015 03:43:05 PM INFO: Cell returned
09/11/2015 03:43:05 PM INFO: Running cell:
lp = ARMA(-0.9)
wl = 65


fig, ax = plt.subplots(3, 1, figsize=(10,12))

for i in range(3):
    X = lp.simulation(ts_length=150)
    ax[i].set_xlim(0, np.pi)

    x_sd, y_sd = lp.spectral_density(two_pi=False, res=180)
    ax[i].semilogy(x_sd, y_sd, 'r-', lw=2, alpha=0.75, label='spectral density')

    x, y_smoothed = periodogram(X, window='hamming', window_len=wl)
    ax[i].semilogy(x, y_smoothed, 'k-', lw=2, alpha=0.75, label='standard smoothed periodogram')

    x, y_ar = ar_periodogram(X, window='hamming', window_len=wl)
    ax[i].semilogy(x, y_ar, 'b-', lw=2, alpha=0.75, label='AR smoothed periodogram')

    ax[i].legend(loc='upper left')




09/11/2015 03:43:15 PM INFO: Cell returned
09/11/2015 03:43:15 PM INFO: Shutdown kernel
---> END 'estspec_solutions.ipynb' <---

---> Executing 'finite_mc_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:43:17 PM INFO: Reading notebook finite_mc_solutions.ipynb
09/11/2015 03:43:19 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:43:19 PM INFO: Cell returned
09/11/2015 03:43:19 PM INFO: Running cell:
from __future__ import print_function, division  # Omit for Python 3.x
import numpy as np
import matplotlib.pyplot as plt
from quantecon import mc_compute_stationary, mc_sample_path


09/11/2015 03:43:22 PM INFO: Cell returned
09/11/2015 03:43:22 PM INFO: Running cell:

alpha = beta = 0.1
N = 10000
p = beta / (alpha + beta)

P = ((1 - alpha, alpha),   # Careful: P and p are distinct
     (beta, 1 - beta))
P = np.array(P)

fig, ax = plt.subplots(figsize=(9, 6))
ax.set_ylim(-0.25, 0.25)
ax.grid()
ax.hlines(0, 0, N, lw=2, alpha=0.6)  # Horizonal line at zero

for x0, col in ((0, 'blue'), (1, 'green')):
    # == Generate time series for worker that starts at x0 == #
    X = mc_sample_path(P, x0, N)
    # == Compute fraction of time spent unemployed, for each n == #
    X_bar = (X == 0).cumsum() / (1 + np.arange(N, dtype=float)) 
    # == Plot == #
    ax.fill_between(range(N), np.zeros(N), X_bar - p, color=col, alpha=0.1)
    ax.plot(X_bar - p, color=col, label=r'$X_0 = \, {} $'.format(x0))
    ax.plot(X_bar - p, 'k-', alpha=0.6)  # Overlay in black--make lines clearer

ax.legend(loc='upper right')



09/11/2015 03:43:23 PM INFO: Cell returned
09/11/2015 03:43:23 PM INFO: Running cell:
%%file web_graph_data.txt
a -> d;
a -> f;
b -> j;
b -> k;
b -> m;
c -> c;
c -> g;
c -> j;
c -> m;
d -> f;
d -> h;
d -> k;
e -> d;
e -> h;
e -> l;
f -> a;
f -> b;
f -> j;
f -> l;
g -> b;
g -> j;
h -> d;
h -> g;
h -> l;
h -> m;
i -> g;
i -> h;
i -> n;
j -> e;
j -> i;
j -> k;
k -> n;
l -> m;
m -> g;
n -> c;
n -> j;
n -> m;


09/11/2015 03:43:23 PM INFO: Cell returned
09/11/2015 03:43:23 PM INFO: Running cell:
"""
Return list of pages, ordered by rank
"""
import numpy as np
from operator import itemgetter
import re

infile = 'web_graph_data.txt'
alphabet = 'abcdefghijklmnopqrstuvwxyz'

n = 14 # Total number of web pages (nodes)

# == Create a matrix Q indicating existence of links == #
#  * Q[i, j] = 1 if there is a link from i to j
#  * Q[i, j] = 0 otherwise
Q = np.zeros((n, n), dtype=int)
f = open(infile, 'r')
edges = f.readlines()
f.close()
for edge in edges:
    from_node, to_node = re.findall('\w', edge)
    i, j = alphabet.index(from_node), alphabet.index(to_node)
    Q[i, j] = 1
# == Create the corresponding Markov matrix P == #
P = np.empty((n, n))
for i in range(n):
    P[i,:] = Q[i,:] / Q[i,:].sum()
# == Compute the stationary distribution r == #
r = mc_compute_stationary(P)[0]
ranked_pages = {alphabet[i] : r[i] for i in range(n)}
# == Print solution, sorted from highest to lowest rank == #
print('Rankings\n ***')
for name, rank in sorted(ranked_pages.items(), key=itemgetter(1), reverse=1):
    print('{0}: {1:.4}'.format(name, rank))



09/11/2015 03:43:24 PM INFO: Cell returned
09/11/2015 03:43:24 PM INFO: Running cell:


09/11/2015 03:43:24 PM INFO: Cell returned
09/11/2015 03:43:24 PM INFO: Running cell:


09/11/2015 03:43:24 PM INFO: Cell returned
09/11/2015 03:43:24 PM INFO: Running cell:


09/11/2015 03:43:24 PM INFO: Cell returned
09/11/2015 03:43:24 PM INFO: Shutdown kernel
---> END 'finite_mc_solutions.ipynb' <---

---> Executing 'ifp_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:43:26 PM INFO: Reading notebook ifp_solutions.ipynb
09/11/2015 03:43:27 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:43:27 PM INFO: Cell returned
09/11/2015 03:43:27 PM INFO: Running cell:
import numpy as np
import matplotlib.pyplot as plt
from quantecon import compute_fixed_point
from quantecon.models import ConsumerProblem

09/11/2015 03:43:29 PM INFO: Cell returned
09/11/2015 03:43:29 PM INFO: Running cell:
cp = ConsumerProblem()
K = 80

# Bellman iteration 
V, c = cp.initialize()
print("Starting value function iteration")
for i in range(K):
    # print "Current iterate = " + str(i)
    V = cp.bellman_operator(V)  
c1 = cp.bellman_operator(V, return_policy=True)  

# Policy iteration 
print("Starting policy function iteration")
V, c2 = cp.initialize()
for i in range(K):
    # print "Current iterate = " + str(i)
    c2 = cp.coleman_operator(c2)

fig, ax = plt.subplots(figsize=(10, 8))
ax.plot(cp.asset_grid, c1[:, 0], label='value function iteration')
ax.plot(cp.asset_grid, c2[:, 0], label='policy function iteration')
ax.set_xlabel('asset level')
ax.set_ylabel('consumption (low income)')
ax.legend(loc='upper left')
plt.show()

09/11/2015 03:43:42 PM INFO: Cell returned
09/11/2015 03:43:42 PM INFO: Running cell:

r_vals = np.linspace(0, 0.04, 4)  

fig, ax = plt.subplots(figsize=(10, 8))
for r_val in r_vals:
    cp = ConsumerProblem(r=r_val)
    v_init, c_init = cp.initialize()
    c = compute_fixed_point(cp.coleman_operator, c_init, verbose=False)
    ax.plot(cp.asset_grid, c[:, 0], label=r'$r = %.3f$' % r_val)

ax.set_xlabel('asset level')
ax.set_ylabel('consumption (low income)')
ax.legend(loc='upper left')
plt.show()

09/11/2015 03:43:52 PM INFO: Cell returned
09/11/2015 03:43:52 PM INFO: Running cell:

from scipy import interp
from quantecon import mc_sample_path 

def compute_asset_series(cp, T=500000, verbose=False):
    """
    Simulates a time series of length T for assets, given optimal savings
    behavior.  Parameter cp is an instance of consumerProblem
    """

    Pi, z_vals, R = cp.Pi, cp.z_vals, cp.R  # Simplify names
    v_init, c_init = cp.initialize()
    c = compute_fixed_point(cp.coleman_operator, c_init, verbose=verbose)
    cf = lambda a, i_z: interp(a, cp.asset_grid, c[:, i_z])
    a = np.zeros(T+1)
    z_seq = mc_sample_path(Pi, sample_size=T)
    for t in range(T):
        i_z = z_seq[t]
        a[t+1] = R * a[t] + z_vals[i_z] - cf(a[t], i_z)
    return a

cp = ConsumerProblem(r=0.03, grid_max=4)
a = compute_asset_series(cp)
fig, ax = plt.subplots(figsize=(10, 8))
ax.hist(a, bins=20, alpha=0.5, normed=True)
ax.set_xlabel('assets')
ax.set_xlim(-0.05, 0.75)
plt.show()

09/11/2015 03:44:00 PM INFO: Cell returned
09/11/2015 03:44:00 PM INFO: Running cell:

M = 25
r_vals = np.linspace(0, 0.04, M)  
fig, ax = plt.subplots(figsize=(10,8))

for b in (1, 3):
    asset_mean = []
    for r_val in r_vals:
        cp = ConsumerProblem(r=r_val, b=b)
        mean = np.mean(compute_asset_series(cp, T=250000))
        asset_mean.append(mean)
    ax.plot(asset_mean, r_vals, label=r'$b = %d$' % b)
    print("Finished iteration b=%i" % b)

ax.set_yticks(np.arange(.0, 0.045, .01))
ax.set_xticks(np.arange(-3, 2, 1))
ax.set_xlabel('capital')
ax.set_ylabel('interest rate')
ax.grid(True)
ax.legend(loc='upper left')
plt.show()

09/11/2015 03:47:07 PM INFO: Cell returned
09/11/2015 03:47:07 PM INFO: Shutdown kernel
---> END 'ifp_solutions.ipynb' <---

---> Executing 'jv_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:47:09 PM INFO: Reading notebook jv_solutions.ipynb
09/11/2015 03:47:10 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:47:10 PM INFO: Cell returned
09/11/2015 03:47:10 PM INFO: Running cell:
import numpy as np
import matplotlib.pyplot as plt
import random
from quantecon import compute_fixed_point
from quantecon.models import JvWorker

09/11/2015 03:47:12 PM INFO: Cell returned
09/11/2015 03:47:12 PM INFO: Running cell:

wp = JvWorker(grid_size=25)
G, pi, F = wp.G, wp.pi, wp.F       # Simplify names

v_init = wp.x_grid * 0.5
print("Computing value function")
V = compute_fixed_point(wp.bellman_operator, v_init, max_iter=40, verbose=False)
print("Computing policy functions")
s_policy, phi_policy = wp.bellman_operator(V, return_policies=True)

# Turn the policy function arrays into actual functions
s = lambda y: np.interp(y, wp.x_grid, s_policy)
phi = lambda y: np.interp(y, wp.x_grid, phi_policy)

def h(x, b, U):
    return (1 - b) * G(x, phi(x)) + b * max(G(x, phi(x)), U)

plot_grid_max, plot_grid_size = 1.2, 100
plot_grid = np.linspace(0, plot_grid_max, plot_grid_size)
fig, ax = plt.subplots(figsize=(8,8))
ax.set_xlim(0, plot_grid_max)
ax.set_ylim(0, plot_grid_max)
ticks = (0.25, 0.5, 0.75, 1.0)
ax.set_xticks(ticks)
ax.set_yticks(ticks)
ax.set_xlabel(r'$x_t$', fontsize=16)
ax.set_ylabel(r'$x_{t+1}$', fontsize=16, rotation='horizontal')

ax.plot(plot_grid, plot_grid, 'k--')  # 45 degree line
for x in plot_grid:
    for i in range(50):
        b = 1 if random.uniform(0, 1) < pi(s(x)) else 0
        U = wp.F.rvs(1)
        y = h(x, b, U)
        ax.plot(x, y, 'go', alpha=0.25)

plt.show()

09/11/2015 03:47:46 PM INFO: Cell returned
09/11/2015 03:47:46 PM INFO: Running cell:

wp = JvWorker(grid_size=25)

def xbar(phi):
    return (wp.A * phi**wp.alpha)**(1 / (1 - wp.alpha))

phi_grid = np.linspace(0, 1, 100)
fig, ax = plt.subplots(figsize=(9, 7))
ax.set_xlabel(r'$\phi$', fontsize=16)
ax.plot(phi_grid, [xbar(phi) * (1 - phi) for phi in phi_grid], 'b-', label=r'$w^*(\phi)$')
ax.legend(loc='upper left')

plt.show()

09/11/2015 03:47:47 PM INFO: Cell returned
09/11/2015 03:47:47 PM INFO: Shutdown kernel
---> END 'jv_solutions.ipynb' <---

---> Executing 'kalman_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:47:49 PM INFO: Reading notebook kalman_solutions.ipynb
09/11/2015 03:47:50 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:47:50 PM INFO: Cell returned
09/11/2015 03:47:50 PM INFO: Running cell:
import numpy as np
import matplotlib.pyplot as plt
from quantecon import Kalman
from quantecon import LinearStateSpace
from scipy.stats import norm

09/11/2015 03:47:51 PM INFO: Cell returned
09/11/2015 03:47:51 PM INFO: Running cell:
# == parameters == #
theta = 10  # Constant value of state x_t
A, C, G, H = 1, 0, 1, 1
ss = LinearStateSpace(A, C, G, H, mu_0=theta)

# == set prior, initialize kalman filter == #
x_hat_0, Sigma_0 = 8, 1
kalman = Kalman(ss, x_hat_0, Sigma_0)

# == draw observations of y from state space model == #
N = 5
x, y = ss.simulate(N)
y = y.flatten()

# == set up plot == #
fig, ax = plt.subplots(figsize=(10,8))
xgrid = np.linspace(theta - 5, theta + 2, 200)

for i in range(N):
    # == record the current predicted mean and variance == #
    m, v = [float(z) for z in (kalman.x_hat, kalman.Sigma)]
    # == plot, update filter == #
    ax.plot(xgrid, norm.pdf(xgrid, loc=m, scale=np.sqrt(v)), label=r'$t=%d$' % i)
    kalman.update(y[i])

ax.set_title(r'First %d densities when $\theta = %.1f$' % (N, theta)) 
ax.legend(loc='upper left')

09/11/2015 03:47:53 PM INFO: Cell returned
09/11/2015 03:47:53 PM INFO: Running cell:
from scipy.integrate import quad

epsilon = 0.1
theta = 10  # Constant value of state x_t
A, C, G, H = 1, 0, 1, 1
ss = LinearStateSpace(A, C, G, H, mu_0=theta)

x_hat_0, Sigma_0 = 8, 1
kalman = Kalman(ss, x_hat_0, Sigma_0)

T = 600
z = np.empty(T)
x, y = ss.simulate(T)
y = y.flatten()

for t in range(T):
    # Record the current predicted mean and variance, and plot their densities
    m, v = [float(temp) for temp in (kalman.x_hat, kalman.Sigma)]
    
    f = lambda x: norm.pdf(x, loc=m, scale=np.sqrt(v))
    integral, error = quad(f, theta - epsilon, theta + epsilon)
    z[t] = 1 - integral
    
    kalman.update(y[t])

fig, ax = plt.subplots(figsize=(9, 7))
ax.set_ylim(0, 1)
ax.set_xlim(0, T)
ax.plot(range(T), z) 
ax.fill_between(range(T), np.zeros(T), z, color="blue", alpha=0.2) 

09/11/2015 03:47:55 PM INFO: Cell returned
09/11/2015 03:47:55 PM INFO: Running cell:
from __future__ import print_function  # Remove for Python 3.x
from numpy.random import multivariate_normal
from scipy.linalg import eigvals


# === Define A, C, G, H === #
G = np.identity(2)
H = np.sqrt(0.5) * np.identity(2)

A = [[0.5, 0.4], 
     [0.6, 0.3]]
C = np.sqrt(0.3) * np.identity(2)

# === Set up state space mode, initial value x_0 set to zero === #
ss = LinearStateSpace(A, C, G, H, mu_0 = np.zeros(2))

# === Define the prior density === #
Sigma = [[0.9, 0.3], 
         [0.3, 0.9]]
Sigma = np.array(Sigma)
x_hat = np.array([8, 8])

# === Initialize the Kalman filter === #
kn = Kalman(ss, x_hat, Sigma)

# == Print eigenvalues of A == #
print("Eigenvalues of A:")
print(eigvals(A))

# == Print stationary Sigma == #
S, K = kn.stationary_values()
print("Stationary prediction error variance:")
print(S)

# === Generate the plot === #
T = 50
x, y = ss.simulate(T)

e1 = np.empty(T-1)
e2 = np.empty(T-1)

for t in range(1, T):
    kn.update(y[:,t])
    e1[t-1] = np.sum((x[:,t] - kn.x_hat.flatten())**2)
    e2[t-1] = np.sum((x[:,t] - np.dot(A, x[:,t-1]))**2)

fig, ax = plt.subplots(figsize=(9,6))
ax.plot(range(1, T), e1, 'k-', lw=2, alpha=0.6, label='Kalman filter error') 
ax.plot(range(1, T), e2, 'g-', lw=2, alpha=0.6, label='conditional expectation error') 
ax.legend()



09/11/2015 03:47:56 PM INFO: Cell returned
09/11/2015 03:47:56 PM INFO: Running cell:


09/11/2015 03:47:56 PM INFO: Cell returned
09/11/2015 03:47:56 PM INFO: Shutdown kernel
---> END 'kalman_solutions.ipynb' <---

---> Executing 'lakemodel_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:47:57 PM INFO: Reading notebook lakemodel_solutions.ipynb
09/11/2015 03:47:57 PM INFO: Running cell:
%pylab inline
from quantecon.models import LakeModel

alpha = 0.012
lamb = 0.2486
b = 0.001808
d = 0.0008333
g = b-d
N0 = 100.
e0 = 0.92
u0 = 1-e0
T = 50

09/11/2015 03:47:59 PM INFO: Cell returned
09/11/2015 03:47:59 PM INFO: Running cell:
LM0 = LakeModel(lamb,alpha,b,d)
x0 = LM0.find_steady_state()# initial conditions

print "Initial Steady State: ", x0

09/11/2015 03:47:59 PM INFO: Cell returned
09/11/2015 03:47:59 PM INFO: Running cell:
LM1 = LakeModel(0.2,alpha,b,d)

09/11/2015 03:47:59 PM INFO: Cell returned
09/11/2015 03:47:59 PM INFO: Running cell:
xbar = LM1.find_steady_state() # new steady state
X_path = vstack(LM1.simulate_stock_path(x0*N0,T)) # simulate stocks
x_path = vstack(LM1.simulate_rate_path(x0,T)) # simulate rates
print "New Steady State: ", xbar

09/11/2015 03:47:59 PM INFO: Cell returned
09/11/2015 03:47:59 PM INFO: Running cell:
figure(figsize=[10,9])
subplot(3,1,1)
plot(X_path[:,0])
title(r'Employment')
subplot(3,1,2)
plot(X_path[:,1])
title(r'Unemployment')
subplot(3,1,3)
plot(X_path.sum(1))
title(r'Labor Force')

09/11/2015 03:48:00 PM INFO: Cell returned
09/11/2015 03:48:00 PM INFO: Running cell:
figure(figsize=[10,6])
subplot(2,1,1)
plot(x_path[:,0])
hlines(xbar[0],0,T,'r','--')
title(r'Employment Rate')
subplot(2,1,2)
plot(x_path[:,1])
hlines(xbar[1],0,T,'r','--')
title(r'Unemployment Rate')

09/11/2015 03:48:01 PM INFO: Cell returned
09/11/2015 03:48:01 PM INFO: Running cell:
bhat = 0.003
T_hat = 20
LM1 = LakeModel(lamb,alpha,bhat,d)

09/11/2015 03:48:01 PM INFO: Cell returned
09/11/2015 03:48:01 PM INFO: Running cell:
X_path1 = vstack(LM1.simulate_stock_path(x0*N0,T_hat)) # simulate stocks
x_path1 = vstack(LM1.simulate_rate_path(x0,T_hat)) # simulate rates

09/11/2015 03:48:01 PM INFO: Cell returned
09/11/2015 03:48:01 PM INFO: Running cell:
X_path2 = vstack(LM0.simulate_stock_path(X_path1[-1,:2],T-T_hat+1)) # simulate stocks
x_path2 = vstack(LM0.simulate_rate_path(x_path1[-1,:2],T-T_hat+1)) # simulate rates

09/11/2015 03:48:01 PM INFO: Cell returned
09/11/2015 03:48:01 PM INFO: Running cell:
x_path = vstack([x_path1,x_path2[1:]]) # note [1:] to avoid doubling period 20
X_path = vstack([X_path1,X_path2[1:]]) # note [1:] to avoid doubling period 20

09/11/2015 03:48:01 PM INFO: Cell returned
09/11/2015 03:48:01 PM INFO: Running cell:
figure(figsize=[10,9])
subplot(3,1,1)
plot(X_path[:,0])
title(r'Employment')
subplot(3,1,2)
plot(X_path[:,1])
title(r'Unemployment')
subplot(3,1,3)
plot(X_path.sum(1))
title(r'Labor Force')

09/11/2015 03:48:02 PM INFO: Cell returned
09/11/2015 03:48:02 PM INFO: Running cell:
figure(figsize=[10,6])
subplot(2,1,1)
plot(x_path[:,0])
hlines(x0[0],0,T,'r','--')
title(r'Employment Rate')
subplot(2,1,2)
plot(x_path[:,1])
hlines(x0[1],0,T,'r','--')
title(r'Unemployment Rate')

09/11/2015 03:48:02 PM INFO: Cell returned
09/11/2015 03:48:02 PM INFO: Running cell:


09/11/2015 03:48:02 PM INFO: Cell returned
09/11/2015 03:48:02 PM INFO: Shutdown kernel
---> END 'lakemodel_solutions.ipynb' <---

---> Executing 'lln_clt_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:48:04 PM INFO: Reading notebook lln_clt_solutions.ipynb
09/11/2015 03:48:04 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:48:05 PM INFO: Cell returned
09/11/2015 03:48:05 PM INFO: Running cell:
import numpy as np
import matplotlib.pyplot as plt

09/11/2015 03:48:05 PM INFO: Cell returned
09/11/2015 03:48:05 PM INFO: Running cell:
"""
Illustrates the delta method, a consequence of the central limit theorem.
"""

from scipy.stats import uniform, norm
from matplotlib import rc

# == Specifying font, needs LaTeX integration == #
rc('font',**{'family':'serif','serif':['Palatino']})
rc('text', usetex=True)

# == Set parameters == #
n = 250
replications = 100000
distribution = uniform(loc=0, scale=(np.pi / 2))
mu, s = distribution.mean(), distribution.std()

g = np.sin
g_prime = np.cos

# == Generate obs of sqrt{n} (g(\bar X_n) - g(\mu)) == #
data = distribution.rvs((replications, n)) 
sample_means = data.mean(axis=1)  # Compute mean of each row
error_obs = np.sqrt(n) * (g(sample_means) - g(mu))

# == Plot == #
asymptotic_sd = g_prime(mu) * s
fig, ax = plt.subplots(figsize=(10, 6))
xmin = -3 * g_prime(mu) * s
xmax = -xmin
ax.set_xlim(xmin, xmax)
ax.hist(error_obs, bins=60, alpha=0.5, normed=True)
xgrid = np.linspace(xmin, xmax, 200)
lb = r"$N(0, g'(\mu)^2  \sigma^2)$"
ax.plot(xgrid, norm.pdf(xgrid, scale=asymptotic_sd), 'k-', lw=2, label=lb)
ax.legend()
plt.show()

09/11/2015 03:50:33 PM INFO: Cell returned
09/11/2015 03:50:33 PM INFO: Running cell:
from scipy.stats import uniform, chi2
from scipy.linalg import inv, sqrtm

# == Set parameters == #
n = 250
replications = 50000
dw = uniform(loc=-1, scale=2)  # Uniform(-1, 1)
du = uniform(loc=-2, scale=4)  # Uniform(-2, 2)
sw, su = dw.std(), du.std()
vw, vu = sw**2, su**2
Sigma = ((vw, vw), (vw, vw + vu))
Sigma = np.array(Sigma)

# == Compute Sigma^{-1/2} == #
Q = inv(sqrtm(Sigma))  

# == Generate observations of the normalized sample mean == #
error_obs = np.empty((2, replications))
for i in range(replications):
    # == Generate one sequence of bivariate shocks == #
    X = np.empty((2, n))
    W = dw.rvs(n)
    U = du.rvs(n)
    # == Construct the n observations of the random vector == #
    X[0, :] = W
    X[1, :] = W + U
    # == Construct the i-th observation of Y_n == #
    error_obs[:, i] = np.sqrt(n) * X.mean(axis=1)

# == Premultiply by Q and then take the squared norm == #
temp = np.dot(Q, error_obs)
chisq_obs = np.sum(temp**2, axis=0)

# == Plot == #
fig, ax = plt.subplots(figsize=(10, 6))
xmax = 8
ax.set_xlim(0, xmax)
xgrid = np.linspace(0, xmax, 200)
lb = "Chi-squared with 2 degrees of freedom"
ax.plot(xgrid, chi2.pdf(xgrid, 2), 'k-', lw=2, label=lb)
ax.legend()
ax.hist(chisq_obs, bins=50, normed=True)
plt.show()

09/11/2015 03:50:44 PM INFO: Cell returned
09/11/2015 03:50:44 PM INFO: Shutdown kernel
---> END 'lln_clt_solutions.ipynb' <---

---> Executing 'lqcontrol_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:50:45 PM INFO: Reading notebook lqcontrol_solutions.ipynb
09/11/2015 03:50:46 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:50:47 PM INFO: Cell returned
09/11/2015 03:50:47 PM INFO: Running cell:
from __future__ import division
import numpy as np
import matplotlib.pyplot as plt
from quantecon import LQ

09/11/2015 03:50:49 PM INFO: Cell returned
09/11/2015 03:50:49 PM INFO: Running cell:
# == Model parameters == #
r       = 0.05
beta    = 1 / (1 + r)
T       = 50
c_bar   = 1.5
sigma   = 0.15
mu      = 2
q       = 1e4
m1      = T * (mu / (T/2)**2)
m2      = - (mu / (T/2)**2)

# == Formulate as an LQ problem == #
Q = 1
R = np.zeros((4, 4)) 
Rf = np.zeros((4, 4))
Rf[0, 0] = q
A = [[1 + r, -c_bar, m1, m2], 
     [0,     1,      0,  0],
     [0,     1,      1,  0],
     [0,     1,      2,  1]]
B = [[-1],
     [0],
     [0],
     [0]]
C = [[sigma],
     [0],
     [0],
     [0]]

# == Compute solutions and simulate == #
lq = LQ(Q, R, A, B, C, beta=beta, T=T, Rf=Rf)
x0 = (0, 1, 0, 0)
xp, up, wp = lq.compute_sequence(x0)

# == Convert results back to assets, consumption and income == #
ap = xp[0, :]               # Assets
c = up.flatten() + c_bar    # Consumption
time = np.arange(1, T+1)
income = wp[0, 1:] + m1 * time + m2 * time**2  # Income


# == Plot results == #
n_rows = 2
fig, axes = plt.subplots(n_rows, 1, figsize=(12, 10))

plt.subplots_adjust(hspace=0.5)
for i in range(n_rows):
    axes[i].grid()
    axes[i].set_xlabel(r'Time')
bbox = (0., 1.02, 1., .102)
legend_args = {'bbox_to_anchor' : bbox, 'loc' : 3, 'mode' : 'expand'}
p_args = {'lw' : 2, 'alpha' : 0.7}

axes[0].plot(range(1, T+1), income, 'g-', label="non-financial income", **p_args)
axes[0].plot(range(T), c, 'k-', label="consumption", **p_args)
axes[0].legend(ncol=2, **legend_args)

axes[1].plot(range(T+1), ap.flatten(), 'b-', label="assets", **p_args)
axes[1].plot(range(T+1), np.zeros(T+1), 'k-')
axes[1].legend(ncol=1, **legend_args)

plt.show()

09/11/2015 03:50:50 PM INFO: Cell returned
09/11/2015 03:50:50 PM INFO: Running cell:
# == Model parameters == #
r       = 0.05
beta    = 1 / (1 + r)
T       = 60
K       = 40
c_bar   = 4
sigma   = 0.35
mu      = 4
q       = 1e4
s       = 1
m1      = 2 * mu / K
m2      = - mu / K**2

# == Formulate LQ problem 1 (retirement) == #
Q = 1
R = np.zeros((4, 4)) 
Rf = np.zeros((4, 4))
Rf[0, 0] = q
A = [[1 + r, s - c_bar, 0, 0], 
     [0,     1,      0,  0],
     [0,     1,      1,  0],
     [0,     1,      2,  1]]
B = [[-1],
     [0],
     [0],
     [0]]
C = [[0],
     [0],
     [0],
     [0]]

# == Initialize LQ instance for retired agent == #
lq_retired = LQ(Q, R, A, B, C, beta=beta, T=T-K, Rf=Rf)
# == Iterate back to start of retirement, record final value function == #
for i in range(T-K):
    lq_retired.update_values()
Rf2 = lq_retired.P

# == Formulate LQ problem 2 (working life) == #
R = np.zeros((4, 4)) 
A = [[1 + r, -c_bar, m1, m2], 
     [0,     1,      0,  0],
     [0,     1,      1,  0],
     [0,     1,      2,  1]]
B = [[-1],
     [0],
     [0],
     [0]]
C = [[sigma],
     [0],
     [0],
     [0]]

# == Set up working life LQ instance with terminal Rf from lq_retired == #
lq_working = LQ(Q, R, A, B, C, beta=beta, T=K, Rf=Rf2)

# == Simulate working state / control paths == #
x0 = (0, 1, 0, 0)
xp_w, up_w, wp_w = lq_working.compute_sequence(x0)
# == Simulate retirement paths (note the initial condition) == #
xp_r, up_r, wp_r = lq_retired.compute_sequence(xp_w[:, K]) 

# == Convert results back to assets, consumption and income == #
xp = np.column_stack((xp_w, xp_r[:, 1:]))
assets = xp[0, :]               # Assets

up = np.column_stack((up_w, up_r))
c = up.flatten() + c_bar    # Consumption

time = np.arange(1, K+1)
income_w = wp_w[0, 1:K+1] + m1 * time + m2 * time**2  # Income
income_r = np.ones(T-K) * s
income = np.concatenate((income_w, income_r))

# == Plot results == #
n_rows = 2
fig, axes = plt.subplots(n_rows, 1, figsize=(12, 10))

plt.subplots_adjust(hspace=0.5)
for i in range(n_rows):
    axes[i].grid()
    axes[i].set_xlabel(r'Time')
bbox = (0., 1.02, 1., .102)
legend_args = {'bbox_to_anchor' : bbox, 'loc' : 3, 'mode' : 'expand'}
p_args = {'lw' : 2, 'alpha' : 0.7}

axes[0].plot(range(1, T+1), income, 'g-', label="non-financial income", **p_args)
axes[0].plot(range(T), c, 'k-', label="consumption", **p_args)
axes[0].legend(ncol=2, **legend_args)

axes[1].plot(range(T+1), assets, 'b-', label="assets", **p_args)
axes[1].plot(range(T+1), np.zeros(T+1), 'k-')
axes[1].legend(ncol=1, **legend_args)

plt.show()

09/11/2015 03:50:51 PM INFO: Cell returned
09/11/2015 03:50:51 PM INFO: Running cell:
# == Model parameters == #
a0      = 5
a1      = 0.5
sigma   = 0.15
rho     = 0.9
gamma   = 1
beta    = 0.95
c       = 2
T       = 120

# == Useful constants == #
m0 = (a0 - c) / (2 * a1)
m1 = 1 / (2 * a1)

# == Formulate LQ problem == #
Q = gamma
R = [[a1, -a1, 0],
     [-a1, a1, 0],
     [0,   0,  0]]
A = [[rho, 0, m0 * (1 - rho)],
     [0,   1, 0],
     [0,   0, 1]]

B = [[0],
     [1],
     [0]]
C = [[m1 * sigma],
     [0],
     [0]]

lq = LQ(Q, R, A, B, C=C, beta=beta)

# == Simulate state / control paths == #
x0 = (m0, 2, 1)
xp, up, wp = lq.compute_sequence(x0, ts_length=150)
q_bar = xp[0, :] 
q     = xp[1, :]

# == Plot simulation results == #
fig, ax = plt.subplots(figsize=(10, 6.5))
ax.set_xlabel('Time')

# == Some fancy plotting stuff -- simplify if you prefer == #
bbox = (0., 1.01, 1., .101)
legend_args = {'bbox_to_anchor' : bbox, 'loc' : 3, 'mode' : 'expand'}
p_args = {'lw' : 2, 'alpha' : 0.6}

time = range(len(q))
ax.set_xlim(0, max(time))
ax.plot(time, q_bar, 'k-', lw=2, alpha=0.6, label=r'$\bar q_t$')
ax.plot(time, q, 'b-', lw=2, alpha=0.6, label=r'$q_t$')
ax.legend(ncol=2, **legend_args)
s = r'dynamics with $\gamma = {}$'.format(gamma)
ax.text(max(time) * 0.6, 1 * q_bar.max(), s, fontsize=14)
plt.show()

09/11/2015 03:50:52 PM INFO: Cell returned
09/11/2015 03:50:52 PM INFO: Shutdown kernel
---> END 'lqcontrol_solutions.ipynb' <---

---> Executing 'lqramsey_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:50:53 PM INFO: Reading notebook lqramsey_solutions.ipynb
09/11/2015 03:50:54 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:50:55 PM INFO: Cell returned
09/11/2015 03:50:55 PM INFO: Running cell:
import sys
import os
import numpy as np
import matplotlib.pyplot as plt

# lqramsy.py lives in the examples folder. We need
# to append it to the path so we can import it below
sys.path.append(os.path.abspath("../examples"))

09/11/2015 03:50:55 PM INFO: Cell returned
09/11/2015 03:50:55 PM INFO: Running cell:
from numpy import array
from lqramsey import *

# == Parameters == #
beta = 1 / 1.05   
rho, mg = .95, .35
A = array([[0, 0, 0, rho, mg*(1-rho)],
           [1, 0, 0, 0, 0],
           [0, 1, 0, 0, 0],
           [0, 0, 1, 0, 0],
           [0, 0, 0, 0, 1]])
C = np.zeros((5, 1))
C[0, 0] = np.sqrt(1 - rho**2) * mg / 8
Sg = array((1, 0, 0, 0, 0)).reshape(1, 5)        
Sd = array((0, 0, 0, 0, 0)).reshape(1, 5)       
Sb = array((0, 0, 0, 0, 2.135)).reshape(1, 5)  # Chosen st. (Sc + Sg) * x0 = 1
Ss = array((0, 0, 0, 0, 0)).reshape(1, 5)

economy = Economy(beta=beta, 
        Sg=Sg, 
        Sd=Sd, 
        Sb=Sb, 
        Ss=Ss, 
        discrete=False, 
        proc=(A, C))

T = 50
path = compute_paths(T, economy)
gen_fig_1(path)

09/11/2015 03:50:59 PM INFO: Cell returned
09/11/2015 03:50:59 PM INFO: Shutdown kernel
---> END 'lqramsey_solutions.ipynb' <---

---> Executing 'lss_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:51:00 PM INFO: Reading notebook lss_solutions.ipynb
09/11/2015 03:51:01 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:51:02 PM INFO: Cell returned
09/11/2015 03:51:02 PM INFO: Running cell:
import numpy as np
import matplotlib.pyplot as plt
from quantecon import LinearStateSpace

09/11/2015 03:51:04 PM INFO: Cell returned
09/11/2015 03:51:04 PM INFO: Running cell:
phi_0, phi_1, phi_2 = 1.1, 0.8, -0.8

A = [[1,     0,     0],
     [phi_0, phi_1, phi_2],
     [0,     1,     0]]
C = np.zeros((3, 1))
G = [0, 1, 0]

ar = LinearStateSpace(A, C, G, mu_0=np.ones(3))
x, y = ar.simulate(ts_length=50)

fig, ax = plt.subplots(figsize=(8, 4.6))
y = y.flatten()
ax.plot(y, 'b-', lw=2, alpha=0.7)
ax.grid()
ax.set_xlabel('time')
ax.set_ylabel(r'$y_t$', fontsize=16)
plt.show()

09/11/2015 03:51:05 PM INFO: Cell returned
09/11/2015 03:51:05 PM INFO: Running cell:
phi_1, phi_2, phi_3, phi_4 = 0.5, -0.2, 0, 0.5
sigma = 0.2

A = [[phi_1, phi_2, phi_3, phi_4],
     [1,     0,     0,     0],
     [0,     1,     0,     0],
     [0,     0,     1,     0]]
C = [[sigma], 
     [0], 
     [0], 
     [0]]
G = [1, 0, 0, 0]

ar = LinearStateSpace(A, C, G, mu_0=np.ones(4))
x, y = ar.simulate(ts_length=200)

fig, ax = plt.subplots(figsize=(8, 4.6))
y = y.flatten()
ax.plot(y, 'b-', lw=2, alpha=0.7)
ax.grid()
ax.set_xlabel('time')
ax.set_ylabel(r'$y_t$', fontsize=16)
plt.show()


09/11/2015 03:51:05 PM INFO: Cell returned
09/11/2015 03:51:05 PM INFO: Running cell:
from __future__ import division
from scipy.stats import norm
import random

phi_1, phi_2, phi_3, phi_4 = 0.5, -0.2, 0, 0.5
sigma = 0.1

A = [[phi_1, phi_2, phi_3, phi_4],
     [1,     0,     0,     0],
     [0,     1,     0,     0],
     [0,     0,     1,     0]]
C = [[sigma], 
     [0], 
     [0], 
     [0]]
G = [1, 0, 0, 0]

I = 20
T = 50
ar = LinearStateSpace(A, C, G, mu_0=np.ones(4))
ymin, ymax = -0.5, 1.15

fig, ax = plt.subplots(figsize=(8, 5))

ax.set_ylim(ymin, ymax)
ax.set_xlabel(r'time', fontsize=16)
ax.set_ylabel(r'$y_t$', fontsize=16)

ensemble_mean = np.zeros(T)
for i in range(I):
    x, y = ar.simulate(ts_length=T)
    y = y.flatten()
    ax.plot(y, 'c-', lw=0.8, alpha=0.5)
    ensemble_mean = ensemble_mean + y

ensemble_mean = ensemble_mean / I
ax.plot(ensemble_mean, color='b', lw=2, alpha=0.8, label=r'$\bar y_t$')

m = ar.moment_sequence()
population_means = []
for t in range(T):
    mu_x, mu_y, Sigma_x, Sigma_y = next(m)
    population_means.append(float(mu_y))
ax.plot(population_means, color='g', lw=2, alpha=0.8, label=r'$G\mu_t$')
ax.legend(ncol=2)
plt.show()

09/11/2015 03:51:06 PM INFO: Cell returned
09/11/2015 03:51:06 PM INFO: Running cell:
phi_1, phi_2, phi_3, phi_4 = 0.5, -0.2, 0, 0.5
sigma = 0.1

A = [[phi_1, phi_2, phi_3, phi_4],
     [1,     0,     0,     0],
     [0,     1,     0,     0],
     [0,     0,     1,     0]]
C = [[sigma], 
     [0], 
     [0], 
     [0]]
G = [1, 0, 0, 0]

T0 = 10
T1 = 50
T2 = 75
T4 = 100

ar = LinearStateSpace(A, C, G, mu_0=np.ones(4))
ymin, ymax = -0.6, 0.6

fig, ax = plt.subplots(figsize=(8, 5))

ax.grid(alpha=0.4)
ax.set_ylim(ymin, ymax)
ax.set_ylabel(r'$y_t$', fontsize=16)
ax.vlines((T0, T1, T2), -1.5, 1.5)

ax.set_xticks((T0, T1, T2))
ax.set_xticklabels((r"$T$", r"$T'$", r"$T''$"), fontsize=14)

mu_x, mu_y, Sigma_x, Sigma_y = ar.stationary_distributions()
ar.mu_0 = mu_x
ar.Sigma_0 = Sigma_x

for i in range(80):
    rcolor = random.choice(('c', 'g', 'b'))
    x, y = ar.simulate(ts_length=T4)
    y = y.flatten()
    ax.plot(y, color=rcolor, lw=0.8, alpha=0.5)
    ax.plot((T0, T1, T2), (y[T0], y[T1], y[T2],), 'ko', alpha=0.5)


09/11/2015 03:51:08 PM INFO: Cell returned
09/11/2015 03:51:08 PM INFO: Running cell:


09/11/2015 03:51:08 PM INFO: Cell returned
09/11/2015 03:51:08 PM INFO: Shutdown kernel
---> END 'lss_solutions.ipynb' <---

---> Executing 'lucas_asset_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:51:10 PM INFO: Reading notebook lucas_asset_solutions.ipynb
09/11/2015 03:51:10 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:51:11 PM INFO: Cell returned
09/11/2015 03:51:11 PM INFO: Running cell:
from __future__ import division  # Omit for Python 3.x
import numpy as np
import matplotlib.pyplot as plt
from quantecon.models import LucasTree

09/11/2015 03:51:13 PM INFO: Cell returned
09/11/2015 03:51:13 PM INFO: Running cell:
fig, ax = plt.subplots(figsize=(10,7))

ax.set_xlabel(r'$y$', fontsize=16)
ax.set_ylabel(r'price', fontsize=16)

for beta in (.95, 0.98):
    print("Comuting at beta = {}".format(beta))
    tree = LucasTree(gamma=2, beta=beta, alpha=0.90, sigma=0.1)
    grid, price_vals = tree.grid, tree.compute_lt_price()
    label = r'$\beta = {}$'.format(beta)
    ax.plot(grid, price_vals, lw=2, alpha=0.7, label=label)

ax.legend(loc='upper left')
ax.set_xlim(min(grid), max(grid))

09/11/2015 03:51:17 PM INFO: Cell returned
09/11/2015 03:51:17 PM INFO: Running cell:


09/11/2015 03:51:17 PM INFO: Cell returned
09/11/2015 03:51:17 PM INFO: Shutdown kernel
---> END 'lucas_asset_solutions.ipynb' <---

---> Executing 'mpe_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:51:17 PM INFO: Reading notebook mpe_solutions.ipynb
09/11/2015 03:51:18 PM INFO: Running cell:
import numpy as np
import quantecon as qe
import matplotlib.pyplot as plt
from numpy import dot

09/11/2015 03:51:21 PM INFO: Cell returned
09/11/2015 03:51:21 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:51:21 PM INFO: Cell returned
09/11/2015 03:51:21 PM INFO: Running cell:
# == Parameters == #
a0    = 10.0
a1    = 2.0
beta  = 0.96
gamma = 12.0

# == In LQ form == #

A  = np.eye(3)

B1 = np.array([[0.], [1.], [0.]])
B2 = np.array([[0.], [0.], [1.]])


R1 = [[0.,    -a0/2,  0.],
      [-a0/2., a1,    a1/2.],
      [0,      a1/2., 0.]]

R2 = [[0.,    0.,   -a0/2],
      [0.,    0.,    a1/2.],
      [-a0/2, a1/2., a1]]

Q1 = Q2 = gamma

S1 = S2 = W1 = W2 = M1 = M2 = 0.0

# == Solve using QE's nnash function == #
F1, F2, P1, P2 = qe.nnash(A, B1, B2, R1, R2, Q1, Q2, S1, S2, W1, W2, M1, M2,
                       beta=beta)

09/11/2015 03:51:21 PM INFO: Cell returned
09/11/2015 03:51:21 PM INFO: Running cell:
AF = A - B1.dot(F1) - B2.dot(F2)
n = 20
x = np.empty((3, n))
x[:, 0] = 1, 1, 1   
for t in range(n-1):
    x[:, t+1] = np.dot(AF, x[:, t])
q1 = x[1, :]
q2 = x[2, :]
q = q1 + q2       # Total output, MPE
p = a0 - a1 * q   # Price, MPE

09/11/2015 03:51:21 PM INFO: Cell returned
09/11/2015 03:51:21 PM INFO: Running cell:
R = a1
Q = gamma
A = B = 1
lq_alt = qe.LQ(Q, R, A, B, beta=beta)
P, F, d = lq_alt.stationary_values()
q_bar = a0 / (2.0 * a1)
qm = np.empty(n)
qm[0] = 2
x0 = qm[0] - q_bar
x = x0
for i in range(1, n):
    x = A * x - B * F * x
    qm[i] = float(x) + q_bar
pm = a0 - a1 * qm

09/11/2015 03:51:21 PM INFO: Cell returned
09/11/2015 03:51:21 PM INFO: Running cell:
fig, axes = plt.subplots(2, 1, figsize=(9, 9))

ax = axes[0]
ax.plot(qm, 'b-', lw=2, alpha=0.75, label='monopolist output')
ax.plot(q, 'g-', lw=2, alpha=0.75, label='MPE total output')
ax.set_ylabel("output")
ax.set_xlabel("time")
ax.set_ylim(2, 4)
ax.legend(loc='upper left', frameon=0)


ax = axes[1]
ax.plot(pm, 'b-', lw=2, alpha=0.75, label='monopolist price')
ax.plot(p, 'g-', lw=2, alpha=0.75, label='MPE price')
ax.set_ylabel("price")
ax.set_xlabel("time")
ax.legend(loc='upper right', frameon=0)

09/11/2015 03:51:22 PM INFO: Cell returned
09/11/2015 03:51:22 PM INFO: Running cell:
delta   = 0.02
D       = np.array([[-1, 0.5], [0.5, -1]])
b       = np.array([25, 25])
c1 = c2 = np.array([1, -2, 1])
e1 = e2 = np.array([10, 10, 3])

delta_1 = 1 - delta

09/11/2015 03:51:22 PM INFO: Cell returned
09/11/2015 03:51:22 PM INFO: Running cell:
# ==  Create matrices needed to compute the Nash feedback equilibrium == #

A = np.array([[delta_1, 0, -delta_1*b[0]],
              [0, delta_1, -delta_1*b[1]],
              [0, 0, 1]])

B1 = delta_1 * np.array([[1, -D[0, 0]],
                        [0, -D[1, 0]],
                        [0, 0]])
B2 = delta_1 * np.array([[0, -D[0, 1]],
                        [1, -D[1, 1]],
                        [0, 0]])

R1 = -np.array([[0.5*c1[2], 0, 0.5*c1[1]],
               [0, 0, 0],
               [0.5*c1[1], 0, c1[0]]])
R2 = -np.array([[0, 0, 0],
               [0, 0.5*c2[2], 0.5*c2[1]],
               [0, 0.5*c2[1], c2[0]]])

Q1 = np.array([[-0.5*e1[2], 0], [0, D[0, 0]]])
Q2 = np.array([[-0.5*e2[2], 0], [0, D[1, 1]]])

S1 = np.zeros((2, 2))
S2 = np.copy(S1)

W1 = np.array([[0, 0],
              [0, 0],
              [-0.5*e1[1], b[0]/2.]])
W2 = np.array([[0, 0],
              [0, 0],
              [-0.5*e2[1], b[1]/2.]])

M1 = np.array([[0, 0], [0, D[0, 1] / 2.]])
M2 = np.copy(M1)

09/11/2015 03:51:22 PM INFO: Cell returned
09/11/2015 03:51:22 PM INFO: Running cell:
F1, F2, P1, P2 = qe.nnash(A, B1, B2, R1, R2, Q1, Q2, S1, S2, W1, W2, M1, M2)

print("\nFirm 1's feedback rule:\n")
print(F1)

print("\nFirm 2's feedback rule:\n")
print(F2)

09/11/2015 03:51:22 PM INFO: Cell returned
09/11/2015 03:51:22 PM INFO: Running cell:
AF = A - B1.dot(F1) - B2.dot(F2)
n = 25
x = np.empty((3, n))
x[:, 0] = 2, 0, 1
for t in range(n-1):
    x[:, t+1] = np.dot(AF, x[:, t])
I1 = x[0, :]
I2 = x[1, :]
fig, ax = plt.subplots(figsize=(9, 5))
ax.plot(I1, 'b-', lw=2, alpha=0.75, label='inventories, firm 1')
ax.plot(I2, 'g-', lw=2, alpha=0.75, label='inventories, firm 2')
ax.set_title(r'$\delta = {}$'.format(delta))
ax.legend()

09/11/2015 03:51:23 PM INFO: Cell returned
09/11/2015 03:51:23 PM INFO: Running cell:


09/11/2015 03:51:23 PM INFO: Cell returned
09/11/2015 03:51:23 PM INFO: Shutdown kernel
---> END 'mpe_solutions.ipynb' <---

---> Executing 'numpy_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:51:24 PM INFO: Reading notebook numpy_solutions.ipynb
09/11/2015 03:51:25 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:51:26 PM INFO: Cell returned
09/11/2015 03:51:26 PM INFO: Running cell:
import numpy as np
import matplotlib.pyplot as plt

09/11/2015 03:51:26 PM INFO: Cell returned
09/11/2015 03:51:26 PM INFO: Running cell:
def p(x, coef):
    X = np.empty(len(coef))
    X[0] = 1
    X[1:] = x
    y = np.cumprod(X)   # y = [1, x, x**2,...]
    return np.dot(coef, y)

09/11/2015 03:51:26 PM INFO: Cell returned
09/11/2015 03:51:26 PM INFO: Running cell:
coef = np.ones(3)
print(coef)
print(p(1, coef))
# For comparison
q = np.poly1d(coef)
print(q(1))

09/11/2015 03:51:26 PM INFO: Cell returned
09/11/2015 03:51:26 PM INFO: Running cell:
from numpy import cumsum
from numpy.random import uniform

class discreteRV:
    """
    Generates an array of draws from a discrete random variable with vector of
    probabilities given by q.  
    """

    def __init__(self, q):
        """
        The argument q is a NumPy array, or array like, nonnegative and sums
        to 1
        """
        self.q = q
        self.Q = cumsum(q)

    def draw(self, k=1):
        """
        Returns k draws from q. For each such draw, the value i is returned
        with probability q[i].
        """
        return self.Q.searchsorted(uniform(0, 1, size=k)) 

09/11/2015 03:51:26 PM INFO: Cell returned
09/11/2015 03:51:26 PM INFO: Running cell:
q = (0.1, 0.9)
d = discreteRV(q)
d.q = (0.5, 0.5)

09/11/2015 03:51:26 PM INFO: Cell returned
09/11/2015 03:51:26 PM INFO: Running cell:
"""
Modifies ecdf.py from QuantEcon to add in a plot method

"""

import numpy as np
import matplotlib.pyplot as plt


class ECDF(object):
    """
    One-dimensional empirical distribution function given a vector of
    observations.

    Parameters
    ----------
    observations : array_like
        An array of observations

    Attributes
    ----------
    observations : array_like
        An array of observations

    """

    def __init__(self, observations):
        self.observations = np.asarray(observations)

    def __call__(self, x):
        """
        Evaluates the ecdf at x

        Parameters
        ----------
        x : scalar(float)
            The x at which the ecdf is evaluated

        Returns
        -------
        scalar(float)
            Fraction of the sample less than x

        """
        return np.mean(self.observations <= x)

    def plot(self, a=None, b=None):
        """
        Plot the ecdf on the interval [a, b].

        Parameters
        ----------
        a : scalar(float), optional(default=None)
            Lower end point of the plot interval
        b : scalar(float), optional(default=None)
            Upper end point of the plot interval

        """

        # === choose reasonable interval if [a, b] not specified === #
        if a is None:
            a = self.observations.min() - self.observations.std()
        if b is None:
            b = self.observations.max() + self.observations.std()

        # === generate plot === #
        x_vals = np.linspace(a, b, num=100)
        f = np.vectorize(self.__call__)
        plt.plot(x_vals, f(x_vals))
        plt.show()

09/11/2015 03:51:26 PM INFO: Cell returned
09/11/2015 03:51:26 PM INFO: Running cell:
X = np.random.randn(1000)
F = ECDF(X)
F.plot()

09/11/2015 03:51:26 PM INFO: Cell returned
09/11/2015 03:51:26 PM INFO: Running cell:


09/11/2015 03:51:26 PM INFO: Cell returned
09/11/2015 03:51:26 PM INFO: Shutdown kernel
---> END 'numpy_solutions.ipynb' <---

---> Executing 'odu_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:51:27 PM INFO: Reading notebook odu_solutions.ipynb
09/11/2015 03:51:28 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:51:29 PM INFO: Cell returned
09/11/2015 03:51:29 PM INFO: Running cell:
import numpy as np
import matplotlib.pyplot as plt
from quantecon import compute_fixed_point
from quantecon.models import SearchProblem

09/11/2015 03:51:30 PM INFO: Cell returned
09/11/2015 03:51:30 PM INFO: Running cell:
sp = SearchProblem(pi_grid_size=50)

phi_init = np.ones(len(sp.pi_grid)) 
w_bar = compute_fixed_point(sp.res_wage_operator, phi_init)

fig, ax = plt.subplots(figsize=(9, 7))
ax.plot(sp.pi_grid, w_bar, linewidth=2, color='black')
ax.set_ylim(0, 2)
ax.grid(axis='x', linewidth=0.25, linestyle='--', color='0.25')
ax.grid(axis='y', linewidth=0.25, linestyle='--', color='0.25')
ax.fill_between(sp.pi_grid, 0, w_bar, color='blue', alpha=0.15)
ax.fill_between(sp.pi_grid, w_bar, 2, color='green', alpha=0.15)
ax.text(0.42, 1.2, 'reject')
ax.text(0.7, 1.8, 'accept')
plt.show()

09/11/2015 03:51:31 PM INFO: Cell returned
09/11/2015 03:51:31 PM INFO: Running cell:
from scipy import interp
# Set up model and compute the function w_bar
sp = SearchProblem(pi_grid_size=50, F_a=1, F_b=1)
pi_grid, f, g, F, G = sp.pi_grid, sp.f, sp.g, sp.F, sp.G
phi_init = np.ones(len(sp.pi_grid)) 
w_bar_vals = compute_fixed_point(sp.res_wage_operator, phi_init)
w_bar = lambda x: interp(x, pi_grid, w_bar_vals)


class Agent(object):
    """
    Holds the employment state and beliefs of an individual agent.
    """

    def __init__(self, pi=1e-3):
        self.pi = pi
        self.employed = 1

    def update(self, H):
        "Update self by drawing wage offer from distribution H."
        if self.employed == 0:
            w = H.rvs()
            if w >= w_bar(self.pi):
                self.employed = 1
            else:
                self.pi = 1.0 / (1 + ((1 - self.pi) * g(w)) / (self.pi * f(w)))


num_agents = 5000
separation_rate = 0.025  # Fraction of jobs that end in each period 
separation_num = int(num_agents * separation_rate)
agent_indices = list(range(num_agents))
agents = [Agent() for i in range(num_agents)]
sim_length = 600
H = G  # Start with distribution G
change_date = 200  # Change to F after this many periods

unempl_rate = []
for i in range(sim_length):
    if i % 20 == 0:
        print("date =", i)
    if i == change_date:
        H = F
    # Randomly select separation_num agents and set employment status to 0
    np.random.shuffle(agent_indices)
    separation_list = agent_indices[:separation_num]
    for agent_index in separation_list:
        agents[agent_index].employed = 0
    # Update agents
    for agent in agents:
        agent.update(H)
    employed = [agent.employed for agent in agents]
    unempl_rate.append(1 - np.mean(employed))

fig, ax = plt.subplots(figsize=(9, 7))
ax.plot(unempl_rate, lw=2, alpha=0.8, label='unemployment rate')
ax.axvline(change_date, color="red")
ax.legend()
plt.show()

09/11/2015 03:53:47 PM INFO: Cell returned
09/11/2015 03:53:47 PM INFO: Shutdown kernel
---> END 'odu_solutions.ipynb' <---

---> Executing 'oop_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:53:48 PM INFO: Reading notebook oop_solutions.ipynb
09/11/2015 03:53:48 PM INFO: Running cell:
class ECDF(object):

    def __init__(self, observations):
        self.observations = observations

    def __call__(self, x):
        counter = 0.0
        for obs in self.observations:
            if obs <= x:
                counter += 1
        return counter / len(self.observations)

09/11/2015 03:53:48 PM INFO: Cell returned
09/11/2015 03:53:48 PM INFO: Running cell:
# == test == #

from random import uniform
samples = [uniform(0, 1) for i in range(10)]
F = ECDF(samples)

print(F(0.5))  # Evaluate ecdf at x = 0.5

F.observations = [uniform(0, 1) for i in range(1000)]

print(F(0.5))

09/11/2015 03:53:49 PM INFO: Cell returned
09/11/2015 03:53:49 PM INFO: Running cell:
class Polynomial(object):

    def __init__(self, coefficients):
        """
        Creates an instance of the Polynomial class representing 

            p(x) = a_0 x^0 + ... + a_N x^N, 
            
        where a_i = coefficients[i].
        """
        self.coefficients = coefficients

    def __call__(self, x):
        "Evaluate the polynomial at x."
        y = 0
        for i, a in enumerate(self.coefficients):
            y += a * x**i  
        return y

    def differentiate(self):
        "Reset self.coefficients to those of p' instead of p."
        new_coefficients = []
        for i, a in enumerate(self.coefficients):
            new_coefficients.append(i * a)
        # Remove the first element, which is zero
        del new_coefficients[0]  
        # And reset coefficients data to new values
        self.coefficients = new_coefficients


09/11/2015 03:53:49 PM INFO: Cell returned
09/11/2015 03:53:49 PM INFO: Shutdown kernel
---> END 'oop_solutions.ipynb' <---

---> Executing 'optgrowth_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:53:50 PM INFO: Reading notebook optgrowth_solutions.ipynb
09/11/2015 03:53:50 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:53:51 PM INFO: Cell returned
09/11/2015 03:53:51 PM INFO: Running cell:
import numpy as np
import matplotlib.pyplot as plt
from quantecon import compute_fixed_point
from quantecon.models import GrowthModel

09/11/2015 03:53:53 PM INFO: Cell returned
09/11/2015 03:53:53 PM INFO: Running cell:
alpha, beta = 0.65, 0.95
gm = GrowthModel() 
true_sigma = (1 - alpha * beta) * gm.grid**alpha
w = 5 * gm.u(gm.grid) - 25  # Initial condition

fig, ax = plt.subplots(3, 1, figsize=(8, 10))

for i, n in enumerate((2, 4, 6)):
    ax[i].set_ylim(0, 1)
    ax[i].set_xlim(0, 2)
    ax[i].set_yticks((0, 1))
    ax[i].set_xticks((0, 2))

    v_star = compute_fixed_point(gm.bellman_operator, w, max_iter=n)
    sigma = gm.compute_greedy(v_star)

    ax[i].plot(gm.grid, sigma, 'b-', lw=2, alpha=0.8, label='approximate optimal policy')
    ax[i].plot(gm.grid, true_sigma, 'k-', lw=2, alpha=0.8, label='true optimal policy')
    ax[i].legend(loc='upper left')
    ax[i].set_title('{} value function iterations'.format(n))

09/11/2015 03:53:55 PM INFO: Cell returned
09/11/2015 03:53:55 PM INFO: Running cell:
from scipy import interp

gm = GrowthModel() 
w = 5 * gm.u(gm.grid) - 25  # To be used as an initial condition
discount_factors = (0.9, 0.94, 0.98)
series_length = 25

fig, ax = plt.subplots(figsize=(8,5))
ax.set_xlabel("time")
ax.set_ylabel("capital")

for beta in discount_factors:

    # Compute the optimal policy given the discount factor
    gm.beta = beta
    v_star = compute_fixed_point(gm.bellman_operator, w, max_iter=20)
    sigma = gm.compute_greedy(v_star)

    # Compute the corresponding time series for capital
    k = np.empty(series_length)
    k[0] = 0.1
    sigma_function = lambda x: interp(x, gm.grid, sigma)
    for t in range(1, series_length):
        k[t] = gm.f(k[t-1]) - sigma_function(k[t-1])
    ax.plot(k, 'o-', lw=2, alpha=0.75, label=r'$\beta = {}$'.format(beta))

ax.legend(loc='lower right')
plt.show()

09/11/2015 03:54:03 PM INFO: Cell returned
09/11/2015 03:54:03 PM INFO: Shutdown kernel
---> END 'optgrowth_solutions.ipynb' <---

---> Executing 'pandas_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:54:05 PM INFO: Reading notebook pandas_solutions.ipynb
09/11/2015 03:54:06 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:54:07 PM INFO: Cell returned
09/11/2015 03:54:07 PM INFO: Running cell:
import numpy as np
import pandas as pd
import datetime as dt
import pandas.io.data as web
import matplotlib.pyplot as plt

09/11/2015 03:54:07 PM INFO: Cell returned
09/11/2015 03:54:07 PM INFO: Running cell:
ticker_list = {'INTC': 'Intel',
               'MSFT': 'Microsoft',
               'IBM': 'IBM',
               'BHP': 'BHP',
               'RSH': 'RadioShack',
               'TM': 'Toyota',
               'AAPL': 'Apple',
               'AMZN': 'Amazon',
               'BA': 'Boeing',
               'QCOM': 'Qualcomm',
               'KO': 'Coca-Cola',
               'GOOG': 'Google',
               'SNE': 'Sony',
               'PTR': 'PetroChina'}

start = dt.datetime(2013, 1, 1)
end = dt.datetime.today()

price_change = {}

for ticker in ticker_list:
    prices = web.DataReader(ticker, 'yahoo', start, end)
    closing_prices = prices['Close']
    change = 100 * (closing_prices[-1] - closing_prices[0]) / closing_prices[0]
    name = ticker_list[ticker]
    price_change[name] = change

pc = pd.Series(price_change)
pc.sort()
fig, ax = plt.subplots(figsize=(10,8))
pc.plot(kind='bar', ax=ax)

09/11/2015 03:54:10 PM INFO: Cell returned
09/11/2015 03:54:10 PM INFO: Shutdown kernel
---> END 'pandas_solutions.ipynb' <---

---> Executing 'pbe_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:54:11 PM INFO: Reading notebook pbe_solutions.ipynb
09/11/2015 03:54:12 PM INFO: Running cell:
def factorial(n):
    k = 1
    for i in range(n):
        k = k * (i + 1)
    return k

factorial(4)

09/11/2015 03:54:12 PM INFO: Cell returned
09/11/2015 03:54:12 PM INFO: Running cell:
from random import uniform

def binomial_rv(n, p):
    count = 0
    for i in range(n):
        U = uniform(0, 1)
        if U < p:
            count = count + 1    # Or count += 1
    return count

binomial_rv(10, 0.5)

09/11/2015 03:54:12 PM INFO: Cell returned
09/11/2015 03:54:12 PM INFO: Running cell:
from __future__ import division  # Omit if using Python 3.x
from math import sqrt

n = 100000

count = 0
for i in range(n):
    u, v = uniform(0, 1), uniform(0, 1)
    d = sqrt((u - 0.5)**2 + (v - 0.5)**2)
    if d < 0.5:
        count += 1

area_estimate = count / n

print(area_estimate * 4)  # dividing by radius**2

09/11/2015 03:54:12 PM INFO: Cell returned
09/11/2015 03:54:12 PM INFO: Running cell:
payoff = 0
count = 0

for i in range(10):
    U = uniform(0, 1)
    count = count + 1 if U < 0.5 else 0
    if count == 3:
        payoff = 1

print(payoff)

09/11/2015 03:54:12 PM INFO: Cell returned
09/11/2015 03:54:12 PM INFO: Running cell:
%matplotlib inline  

09/11/2015 03:54:13 PM INFO: Cell returned
09/11/2015 03:54:13 PM INFO: Running cell:
import matplotlib.pyplot as plt
from random import normalvariate

alpha = 0.9
ts_length = 200
current_x = 0

x_values = []
for i in range(ts_length + 1):
    x_values.append(current_x)
    current_x = alpha * current_x + normalvariate(0, 1)
plt.plot(x_values, 'b-')


09/11/2015 03:54:13 PM INFO: Cell returned
09/11/2015 03:54:13 PM INFO: Running cell:
alphas = [0.0, 0.8, 0.98]
ts_length = 200

for alpha in alphas:
    x_values = []
    current_x = 0
    for i in range(ts_length):
        x_values.append(current_x)
        current_x = alpha * current_x + normalvariate(0, 1)
    plt.plot(x_values, label='alpha = ' + str(alpha))
plt.legend()

09/11/2015 03:54:13 PM INFO: Cell returned
09/11/2015 03:54:13 PM INFO: Running cell:


09/11/2015 03:54:13 PM INFO: Cell returned
09/11/2015 03:54:13 PM INFO: Shutdown kernel
---> END 'pbe_solutions.ipynb' <---

---> Executing 'py_adv_feat_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:54:15 PM INFO: Reading notebook py_adv_feat_solutions.ipynb
09/11/2015 03:54:16 PM INFO: Running cell:
def x(t):
    if t == 0:
        return 0
    if t == 1:
        return 1
    else:
        return x(t-1) + x(t-2)


09/11/2015 03:54:16 PM INFO: Cell returned
09/11/2015 03:54:16 PM INFO: Running cell:
print([x(i) for i in range(10)])

09/11/2015 03:54:16 PM INFO: Cell returned
09/11/2015 03:54:16 PM INFO: Running cell:
def column_iterator(target_file, column_number):
    """A generator function for CSV files.
    When called with a file name target_file (string) and column number 
    column_number (integer), the generator function returns a generator 
    which steps through the elements of column column_number in file
    target_file.
    """
    f = open(target_file, 'r')
    for line in f:
        yield line.split(',')[column_number - 1]
    f.close()

dates = column_iterator('test_table.csv', 1) 

i = 1
for date in dates:
    print(date)
    if i == 10:
        break
    i += 1

09/11/2015 03:54:16 PM INFO: Cell returned
09/11/2015 03:54:16 PM INFO: Running cell:
%%file numbers.txt
prices
3
8

7
21

09/11/2015 03:54:16 PM INFO: Cell returned
09/11/2015 03:54:16 PM INFO: Running cell:
f = open('numbers.txt')

total = 0.0 
for line in f:
    try:
        total += float(line)
    except ValueError:
        pass

f.close()

print(total)


09/11/2015 03:54:16 PM INFO: Cell returned
09/11/2015 03:54:16 PM INFO: Shutdown kernel
---> END 'py_adv_feat_solutions.ipynb' <---

---> Executing 'pyess_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:54:17 PM INFO: Reading notebook pyess_solutions.ipynb
09/11/2015 03:54:18 PM INFO: Running cell:
from __future__ import division  # Omit for Python 3.x

09/11/2015 03:54:18 PM INFO: Cell returned
09/11/2015 03:54:18 PM INFO: Running cell:
x_vals = [1, 2, 3]
y_vals = [1, 1, 1]
sum([x * y for x, y in zip(x_vals, y_vals)])

09/11/2015 03:54:18 PM INFO: Cell returned
09/11/2015 03:54:18 PM INFO: Running cell:
sum(x * y for x, y in zip(x_vals, y_vals))

09/11/2015 03:54:18 PM INFO: Cell returned
09/11/2015 03:54:18 PM INFO: Running cell:
sum([x % 2 == 0 for x in range(100)])

09/11/2015 03:54:18 PM INFO: Cell returned
09/11/2015 03:54:18 PM INFO: Running cell:
sum(x % 2 == 0 for x in range(100))

09/11/2015 03:54:18 PM INFO: Cell returned
09/11/2015 03:54:18 PM INFO: Running cell:
len([x for x in range(100) if x % 2 == 0])

09/11/2015 03:54:18 PM INFO: Cell returned
09/11/2015 03:54:18 PM INFO: Running cell:
sum([1 for x in range(100) if x % 2 == 0])

09/11/2015 03:54:18 PM INFO: Cell returned
09/11/2015 03:54:18 PM INFO: Running cell:
pairs = ((2, 5), (4, 2), (9, 8), (12, 10))
sum([x % 2 == 0 and y % 2 == 0 for x, y in pairs])

09/11/2015 03:54:18 PM INFO: Cell returned
09/11/2015 03:54:18 PM INFO: Running cell:
def p(x, coeff):
    return sum(a * x**i for i, a in enumerate(coeff))


09/11/2015 03:54:18 PM INFO: Cell returned
09/11/2015 03:54:18 PM INFO: Running cell:
p(1, (2, 4))

09/11/2015 03:54:18 PM INFO: Cell returned
09/11/2015 03:54:18 PM INFO: Running cell:
def f(string):
    count = 0
    for letter in string:
        if letter == letter.upper() and letter.isalpha():
            count += 1
    return count
f('The Rain in Spain')

09/11/2015 03:54:18 PM INFO: Cell returned
09/11/2015 03:54:18 PM INFO: Running cell:
def f(seq_a, seq_b):
    is_subset = True
    for a in seq_a:
        if a not in seq_b:
            is_subset = False
    return is_subset

# == test == #

print(f([1, 2], [1, 2, 3]))
print(f([1, 2, 3], [1, 2]))

09/11/2015 03:54:18 PM INFO: Cell returned
09/11/2015 03:54:18 PM INFO: Running cell:
def f(seq_a, seq_b):
    return set(seq_a).issubset(set(seq_b))

09/11/2015 03:54:18 PM INFO: Cell returned
09/11/2015 03:54:18 PM INFO: Running cell:
def linapprox(f, a, b, n, x):
    """
    Evaluates the piecewise linear interpolant of f at x on the interval 
    [a, b], with n evenly spaced grid points.

    Parameters 
    ===========
        f : function
            The function to approximate

        x, a, b : scalars (floats or integers) 
            Evaluation point and endpoints, with a <= x <= b

        n : integer
            Number of grid points

    Returns
    =========
        A float. The interpolant evaluated at x

    """
    length_of_interval = b - a
    num_subintervals = n - 1
    step = length_of_interval / num_subintervals  

    # === find first grid point larger than x === #
    point = a
    while point <= x:
        point += step

    # === x must lie between the gridpoints (point - step) and point === #
    u, v = point - step, point  

    return f(u) + (x - u) * (f(v) - f(u)) / (v - u)


09/11/2015 03:54:18 PM INFO: Cell returned
09/11/2015 03:54:18 PM INFO: Shutdown kernel
---> END 'pyess_solutions.ipynb' <---

---> Executing 'ree_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:54:19 PM INFO: Reading notebook ree_solutions.ipynb
09/11/2015 03:54:20 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:54:20 PM INFO: Cell returned
09/11/2015 03:54:20 PM INFO: Running cell:
from __future__ import print_function
import numpy as np
import matplotlib.pyplot as plt

09/11/2015 03:54:20 PM INFO: Cell returned
09/11/2015 03:54:20 PM INFO: Running cell:
from quantecon import LQ

09/11/2015 03:54:22 PM INFO: Cell returned
09/11/2015 03:54:22 PM INFO: Running cell:

# == Model parameters == #

a0      = 100
a1      = 0.05
beta    = 0.95
gamma   = 10.0

# == Beliefs == #

kappa0  = 95.5
kappa1  = 0.95

# == Formulate the LQ problem == #

A = np.array([[1, 0, 0], [0, kappa1, kappa0], [0, 0, 1]])
B = np.array([1, 0, 0])
B.shape = 3, 1
R = np.array([[0, a1/2, -a0/2], [a1/2, 0, 0], [-a0/2, 0, 0]])
Q = 0.5 * gamma

# == Solve for the optimal policy == #

lq = LQ(Q, R, A, B, beta=beta)
P, F, d = lq.stationary_values()
F = F.flatten()
out1 = "F = [{0:.3f}, {1:.3f}, {2:.3f}]".format(F[0], F[1], F[2])
h0, h1, h2 = -F[2], 1 - F[0], -F[1]
out2 = "(h0, h1, h2) = ({0:.3f}, {1:.3f}, {2:.3f})".format(h0, h1, h2)

print(out1)
print(out2)


09/11/2015 03:54:22 PM INFO: Cell returned
09/11/2015 03:54:22 PM INFO: Running cell:

candidates = (
          (94.0886298678, 0.923409232937),
          (93.2119845412, 0.984323478873),
          (95.0818452486, 0.952459076301)
             )

for kappa0, kappa1 in candidates:

    # == Form the associated law of motion == #
    A = np.array([[1, 0, 0], [0, kappa1, kappa0], [0, 0, 1]])

    # == Solve the LQ problem for the firm == #
    lq = LQ(Q, R, A, B, beta=beta)
    P, F, d = lq.stationary_values()
    F = F.flatten()
    h0, h1, h2 = -F[2], 1 - F[0], -F[1]

    # == Test the equilibrium condition == #
    if np.allclose((kappa0, kappa1), (h0, h1 + h2)):
        print('Equilibrium pair =', kappa0, kappa1)
        print('(h0, h1, h2) = ', h0, h1, h2)
        break




09/11/2015 03:54:22 PM INFO: Cell returned
09/11/2015 03:54:22 PM INFO: Running cell:

# == Formulate the planner's LQ problem == #

A = np.array([[1, 0], [0, 1]])
B = np.array([[1], [0]])
R = np.array([[a1 / 2, -a0 / 2], [-a0 / 2, 0]])
Q = gamma / 2

# == Solve for the optimal policy == #

lq = LQ(Q, R, A, B, beta=beta)
P, F, d = lq.stationary_values()

# == Print the results == #

F = F.flatten()
kappa0, kappa1 = -F[1], 1 - F[0]
print(kappa0, kappa1)


09/11/2015 03:54:22 PM INFO: Cell returned
09/11/2015 03:54:22 PM INFO: Running cell:

A = np.array([[1, 0], [0, 1]])
B = np.array([[1], [0]])
R = np.array([[a1, -a0 / 2], [-a0 / 2, 0]])
Q = gamma / 2

lq = LQ(Q, R, A, B, beta=beta)
P, F, d = lq.stationary_values()

F = F.flatten()
m0, m1 = -F[1], 1 - F[0]
print(m0, m1)


09/11/2015 03:54:22 PM INFO: Cell returned
09/11/2015 03:54:22 PM INFO: Shutdown kernel
---> END 'ree_solutions.ipynb' <---

---> Executing 'schelling_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:54:23 PM INFO: Reading notebook schelling_solutions.ipynb
09/11/2015 03:54:23 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:54:24 PM INFO: Cell returned
09/11/2015 03:54:24 PM INFO: Running cell:
from random import uniform, seed
from math import sqrt
import matplotlib.pyplot as plt

seed(10)  # for reproducible random numbers

class Agent:

    def __init__(self, type):
        self.type = type
        self.draw_location()

    def draw_location(self):
        self.location = uniform(0, 1), uniform(0, 1)

    def get_distance(self, other):
        "Computes euclidean distance between self and other agent."
        a = (self.location[0] - other.location[0])**2
        b = (self.location[1] - other.location[1])**2
        return sqrt(a + b)

    def happy(self, agents):
        "True if sufficient number of nearest neighbors are of the same type."
        distances = []
        # distances is a list of pairs (d, agent), where d is distance from
        # agent to self
        for agent in agents:
            if self != agent:
                distance = self.get_distance(agent)
                distances.append((distance, agent))
        # == Sort from smallest to largest, according to distance == #
        distances.sort()
        # == Extract the neighboring agents == #
        neighbors = [agent for d, agent in distances[:num_neighbors]]
        # == Count how many neighbors have the same type as self == #
        num_same_type = sum(self.type == agent.type for agent in neighbors)
        return num_same_type >= require_same_type

    def update(self, agents):
        "If not happy, then randomly choose new locations until happy."
        while not self.happy(agents):
            self.draw_location()

            
def plot_distribution(agents, cycle_num):
    "Plot the distribution of agents after cycle_num rounds of the loop."
    x_values_0, y_values_0 = [], []
    x_values_1, y_values_1 = [], []
    # == Obtain locations of each type == #
    for agent in agents:
        x, y = agent.location
        if agent.type == 0:
            x_values_0.append(x)
            y_values_0.append(y)
        else:
            x_values_1.append(x)
            y_values_1.append(y)
    fig, ax = plt.subplots(figsize=(8, 8))
    plot_args = {'markersize' : 8, 'alpha' : 0.6}
    ax.set_axis_bgcolor('azure')
    ax.plot(x_values_0, y_values_0, 'o', markerfacecolor='orange',  **plot_args)
    ax.plot(x_values_1, y_values_1, 'o', markerfacecolor='green', **plot_args)
    ax.set_title('Cycle {}'.format(cycle_num - 1))
    plt.show()

# == Main == #

num_of_type_0 = 250
num_of_type_1 = 250
num_neighbors = 10      # Number of agents regarded as neighbors
require_same_type = 7   # Want at least this many neighbors to be same type

# == Create a list of agents == #
agents = [Agent(0) for i in range(num_of_type_0)]
agents.extend(Agent(1) for i in range(num_of_type_1))


count = 1
# ==  Loop until none wishes to move == #
while 1:
    print('Entering loop ', count)
    plot_distribution(agents, count)
    count += 1
    no_one_moved = True
    for agent in agents:
        old_location = agent.location
        agent.update(agents)
        if agent.location != old_location:
            no_one_moved = False
    if no_one_moved:
        break
        
print('Converged, terminating.')


09/11/2015 03:54:34 PM INFO: Cell returned
09/11/2015 03:54:34 PM INFO: Shutdown kernel
---> END 'schelling_solutions.ipynb' <---

---> Executing 'scipy_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:54:35 PM INFO: Reading notebook scipy_solutions.ipynb
09/11/2015 03:54:35 PM INFO: Running cell:
def bisect(f, a, b, tol=10e-5):
    """
    Implements the bisection root finding algorithm, assuming that f is a
    real-valued function on [a, b] satisfying f(a) < 0 < f(b).
    """
    lower, upper = a, b
    if upper - lower < tol:
        return 0.5 * (upper + lower)
    else:
        middle = 0.5 * (upper + lower)
        print('Current mid point = {}'.format(middle))
        if f(middle) > 0:   # Implies root is between lower and middle
            bisect(f, lower, middle)
        else:               # Implies root is between middle and upper
            bisect(f, middle, upper)


09/11/2015 03:54:35 PM INFO: Cell returned
09/11/2015 03:54:35 PM INFO: Running cell:
import numpy as np
f = lambda x: np.sin(4 * (x - 0.25)) + x + x**20 - 1

bisect(f, 0, 1)

09/11/2015 03:54:36 PM INFO: Cell returned
09/11/2015 03:54:36 PM INFO: Shutdown kernel
---> END 'scipy_solutions.ipynb' <---

---> Executing 'short_path_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:54:37 PM INFO: Reading notebook short_path_solutions.ipynb
09/11/2015 03:54:38 PM INFO: Running cell:
%%file graph.txt
node0, node1 0.04, node8 11.11, node14 72.21
node1, node46 1247.25, node6 20.59, node13 64.94
node2, node66 54.18, node31 166.80, node45 1561.45
node3, node20 133.65, node6 2.06, node11 42.43
node4, node75 3706.67, node5 0.73, node7 1.02
node5, node45 1382.97, node7 3.33, node11 34.54
node6, node31 63.17, node9 0.72, node10 13.10
node7, node50 478.14, node9 3.15, node10 5.85
node8, node69 577.91, node11 7.45, node12 3.18
node9, node70 2454.28, node13 4.42, node20 16.53
node10, node89 5352.79, node12 1.87, node16 25.16
node11, node94 4961.32, node18 37.55, node20 65.08
node12, node84 3914.62, node24 34.32, node28 170.04
node13, node60 2135.95, node38 236.33, node40 475.33
node14, node67 1878.96, node16 2.70, node24 38.65
node15, node91 3597.11, node17 1.01, node18 2.57
node16, node36 392.92, node19 3.49, node38 278.71
node17, node76 783.29, node22 24.78, node23 26.45
node18, node91 3363.17, node23 16.23, node28 55.84
node19, node26 20.09, node20 0.24, node28 70.54
node20, node98 3523.33, node24 9.81, node33 145.80
node21, node56 626.04, node28 36.65, node31 27.06
node22, node72 1447.22, node39 136.32, node40 124.22
node23, node52 336.73, node26 2.66, node33 22.37
node24, node66 875.19, node26 1.80, node28 14.25
node25, node70 1343.63, node32 36.58, node35 45.55
node26, node47 135.78, node27 0.01, node42 122.00
node27, node65 480.55, node35 48.10, node43 246.24
node28, node82 2538.18, node34 21.79, node36 15.52
node29, node64 635.52, node32 4.22, node33 12.61
node30, node98 2616.03, node33 5.61, node35 13.95
node31, node98 3350.98, node36 20.44, node44 125.88
node32, node97 2613.92, node34 3.33, node35 1.46
node33, node81 1854.73, node41 3.23, node47 111.54
node34, node73 1075.38, node42 51.52, node48 129.45
node35, node52 17.57, node41 2.09, node50 78.81
node36, node71 1171.60, node54 101.08, node57 260.46
node37, node75 269.97, node38 0.36, node46 80.49
node38, node93 2767.85, node40 1.79, node42 8.78
node39, node50 39.88, node40 0.95, node41 1.34
node40, node75 548.68, node47 28.57, node54 53.46
node41, node53 18.23, node46 0.28, node54 162.24
node42, node59 141.86, node47 10.08, node72 437.49
node43, node98 2984.83, node54 95.06, node60 116.23
node44, node91 807.39, node46 1.56, node47 2.14
node45, node58 79.93, node47 3.68, node49 15.51
node46, node52 22.68, node57 27.50, node67 65.48
node47, node50 2.82, node56 49.31, node61 172.64
node48, node99 2564.12, node59 34.52, node60 66.44
node49, node78 53.79, node50 0.51, node56 10.89
node50, node85 251.76, node53 1.38, node55 20.10
node51, node98 2110.67, node59 23.67, node60 73.79
node52, node94 1471.80, node64 102.41, node66 123.03
node53, node72 22.85, node56 4.33, node67 88.35
node54, node88 967.59, node59 24.30, node73 238.61
node55, node84 86.09, node57 2.13, node64 60.80
node56, node76 197.03, node57 0.02, node61 11.06
node57, node86 701.09, node58 0.46, node60 7.01
node58, node83 556.70, node64 29.85, node65 34.32
node59, node90 820.66, node60 0.72, node71 0.67
node60, node76 48.03, node65 4.76, node67 1.63
node61, node98 1057.59, node63 0.95, node64 4.88
node62, node91 132.23, node64 2.94, node76 38.43
node63, node66 4.43, node72 70.08, node75 56.34
node64, node80 47.73, node65 0.30, node76 11.98
node65, node94 594.93, node66 0.64, node73 33.23
node66, node98 395.63, node68 2.66, node73 37.53
node67, node82 153.53, node68 0.09, node70 0.98
node68, node94 232.10, node70 3.35, node71 1.66
node69, node99 247.80, node70 0.06, node73 8.99
node70, node76 27.18, node72 1.50, node73 8.37
node71, node89 104.50, node74 8.86, node91 284.64
node72, node76 15.32, node84 102.77, node92 133.06
node73, node83 52.22, node76 1.40, node90 243.00
node74, node81 1.07, node76 0.52, node78 8.08
node75, node92 68.53, node76 0.81, node77 1.19
node76, node85 13.18, node77 0.45, node78 2.36
node77, node80 8.94, node78 0.98, node86 64.32
node78, node98 355.90, node81 2.59
node79, node81 0.09, node85 1.45, node91 22.35
node80, node92 121.87, node88 28.78, node98 264.34
node81, node94 99.78, node89 39.52, node92 99.89
node82, node91 47.44, node88 28.05, node93 11.99
node83, node94 114.95, node86 8.75, node88 5.78
node84, node89 19.14, node94 30.41, node98 121.05
node85, node97 94.51, node87 2.66, node89 4.90
node86, node97 85.09
node87, node88 0.21, node91 11.14, node92 21.23
node88, node93 1.31, node91 6.83, node98 6.12
node89, node97 36.97, node99 82.12
node90, node96 23.53, node94 10.47, node99 50.99
node91, node97 22.17
node92, node96 10.83, node97 11.24, node99 34.68
node93, node94 0.19, node97 6.71, node99 32.77
node94, node98 5.91, node96 2.03
node95, node98 6.17, node99 0.27
node96, node98 3.32, node97 0.43, node99 5.87
node97, node98 0.30
node98, node99 0.33
node99, 

09/11/2015 03:54:38 PM INFO: Cell returned
09/11/2015 03:54:38 PM INFO: Running cell:

def read_graph(in_file):
    """ Read in the graph from the data file.  The graph is stored
    as a dictionary, where the keys are the nodes, and the values
    are a list of pairs (d, c), where d is a node and c is a number.
    If (d, c) is in the list for node n, then d can be reached from
    n at cost c.
    """
    graph = {}
    infile = open(in_file)
    for line in infile:
        elements = line.split(',')
        node = elements.pop(0).strip()
        graph[node] = []
        if node != 'node99':
            for element in elements:
                destination, cost = element.split()
                graph[node].append((destination.strip(), float(cost)))
    infile.close()
    return graph

def update_J(J, graph):
    "The Bellman operator."
    next_J = {}
    for node in graph:
        if node == 'node99':
            next_J[node] = 0
        else:
            next_J[node] = min(cost + J[dest] for dest, cost in graph[node])
    return next_J

def print_best_path(J, graph):
    """ Given a cost-to-go function, computes the best path.  At each node n, 
    the function prints the current location, looks at all nodes that can be 
    reached from n, and moves to the node m which minimizes c + J[m], where c 
    is the cost of moving to m.
    """
    sum_costs = 0
    current_location = 'node0'
    while current_location != 'node99':
        print(current_location)
        running_min = 1e100  # Any big number
        for destination, cost in graph[current_location]:
            cost_of_path = cost + J[destination]
            if cost_of_path < running_min:
                running_min = cost_of_path
                minimizer_cost = cost
                minimizer_dest = destination
        current_location = minimizer_dest
        sum_costs += minimizer_cost

    print('node99\n')
    print('Cost: ', sum_costs)


## Main loop

graph = read_graph('graph.txt')
M = 1e10
J = {}
for node in graph:
    J[node] = M
J['node99'] = 0

while 1:
    next_J = update_J(J, graph)
    if next_J == J:
        break
    else:
        J = next_J
print_best_path(J, graph)

09/11/2015 03:54:38 PM INFO: Cell returned
09/11/2015 03:54:38 PM INFO: Shutdown kernel
---> END 'short_path_solutions.ipynb' <---

---> Executing 'speed_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:54:40 PM INFO: Reading notebook speed_solutions.ipynb
09/11/2015 03:54:40 PM INFO: Running cell:
import matplotlib.pyplot as plt
import numpy as np
from numba import jit

09/11/2015 03:54:41 PM INFO: Cell returned
09/11/2015 03:54:41 PM INFO: Running cell:
p, q = 0.1, 0.2  # Prob of leaving low and high state respectively

09/11/2015 03:54:41 PM INFO: Cell returned
09/11/2015 03:54:41 PM INFO: Running cell:
def compute_series(n):
    x = np.empty(n, dtype=int)
    x[0] = 1  # Start in state 1
    U = np.random.uniform(0, 1, size=n)
    for t in range(1, n):
        current_x = x[t-1]
        if current_x == 0:
            x[t] = U[t] < p
        else:
            x[t] = U[t] > q
    return x

09/11/2015 03:54:41 PM INFO: Cell returned
09/11/2015 03:54:41 PM INFO: Running cell:
n = 100000
x = compute_series(n)
print(np.mean(x == 0))  # Fraction of time x is in state 0

09/11/2015 03:54:41 PM INFO: Cell returned
09/11/2015 03:54:41 PM INFO: Running cell:
%timeit compute_series(n)

09/11/2015 03:54:47 PM INFO: Cell returned
09/11/2015 03:54:47 PM INFO: Running cell:
compute_series_numba = jit(compute_series)

09/11/2015 03:54:47 PM INFO: Cell returned
09/11/2015 03:54:47 PM INFO: Running cell:
x = compute_series_numba(n)
print(np.mean(x == 0))

09/11/2015 03:54:47 PM INFO: Cell returned
09/11/2015 03:54:47 PM INFO: Running cell:
%timeit compute_series_numba(n)

09/11/2015 03:54:49 PM INFO: Cell returned
09/11/2015 03:54:49 PM INFO: Running cell:
%load_ext cythonmagic

09/11/2015 03:54:50 PM INFO: Cell returned
09/11/2015 03:54:50 PM INFO: Running cell:
%%cython
import numpy as np
from numpy cimport int_t, float_t

def compute_series_cy(int n):
    # == Create NumPy arrays first == #
    x_np = np.empty(n, dtype=int)
    U_np = np.random.uniform(0, 1, size=n)
    # == Now create memoryviews of the arrays == #
    cdef int_t [:] x = x_np
    cdef float_t [:] U = U_np
    # == Other variable declarations == #
    cdef float p = 0.1
    cdef float q = 0.2
    cdef int t
    # == Main loop == #
    x[0] = 1  
    for t in range(1, n):
        current_x = x[t-1]
        if current_x == 0:
            x[t] = U[t] < p
        else:
            x[t] = U[t] > q
    return np.asarray(x)

09/11/2015 03:54:50 PM INFO: Cell returned
09/11/2015 03:54:50 PM INFO: Running cell:
compute_series_cy(10)

09/11/2015 03:54:50 PM INFO: Cell returned
09/11/2015 03:54:50 PM INFO: Running cell:
x = compute_series_cy(n)
print(np.mean(x == 0))

09/11/2015 03:54:50 PM INFO: Cell returned
09/11/2015 03:54:50 PM INFO: Running cell:
%timeit compute_series_cy(n)

09/11/2015 03:54:53 PM INFO: Cell returned
09/11/2015 03:54:53 PM INFO: Shutdown kernel
---> END 'speed_solutions.ipynb' <---

---> Executing 'statd_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:54:53 PM INFO: Reading notebook statd_solutions.ipynb
09/11/2015 03:54:54 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:54:55 PM INFO: Cell returned
09/11/2015 03:54:55 PM INFO: Running cell:
import numpy as np
import matplotlib.pyplot as plt

09/11/2015 03:54:55 PM INFO: Cell returned
09/11/2015 03:54:55 PM INFO: Running cell:
from scipy.stats import norm, gaussian_kde
from quantecon import LAE

phi = norm()
n = 500
theta = 0.8
# == Frequently used constants == #
d = np.sqrt(1 - theta**2) 
delta = theta / d

def psi_star(y):
    "True stationary density of the TAR Model"
    return 2 * norm.pdf(y) * norm.cdf(delta * y) 

def p(x, y):
    "Stochastic kernel for the TAR model."
    return phi.pdf((y - theta * np.abs(x)) / d) / d

Z = phi.rvs(n)
X = np.empty(n)
for t in range(n-1):
    X[t+1] = theta * np.abs(X[t]) + d * Z[t]
psi_est = LAE(p, X)
k_est = gaussian_kde(X)

fig, ax = plt.subplots(figsize=(10,7))
ys = np.linspace(-3, 3, 200)
ax.plot(ys, psi_star(ys), 'b-', lw=2, alpha=0.6, label='true')
ax.plot(ys, psi_est(ys), 'g-', lw=2, alpha=0.6, label='look ahead estimate')
ax.plot(ys, k_est(ys), 'k-', lw=2, alpha=0.6, label='kernel based estimate')
ax.legend(loc='upper left')
plt.show()

09/11/2015 03:54:57 PM INFO: Cell returned
09/11/2015 03:54:57 PM INFO: Running cell:
from scipy.stats import lognorm, beta

# == Define parameters == #
s = 0.2
delta = 0.1
a_sigma = 0.4       # A = exp(B) where B ~ N(0, a_sigma)
alpha = 0.4         # f(k) = k**alpha

phi = lognorm(a_sigma) 

def p(x, y):
    "Stochastic kernel, vectorized in x.  Both x and y must be positive."
    d = s * x**alpha
    return phi.pdf((y - (1 - delta) * x) / d) / d

n = 1000     # Number of observations at each date t
T = 40       # Compute density of k_t at 1,...,T

fig, axes = plt.subplots(2, 2, figsize=(11, 8))
axes = axes.flatten()
xmax = 6.5

for i in range(4):
    ax = axes[i] 
    ax.set_xlim(0, xmax)
    psi_0 = beta(5, 5, scale=0.5, loc=i*2)  # Initial distribution

    # == Generate matrix s.t. t-th column is n observations of k_t == #
    k = np.empty((n, T))
    A = phi.rvs((n, T))
    k[:, 0] = psi_0.rvs(n)
    for t in range(T-1):
        k[:, t+1] = s * A[:,t] * k[:, t]**alpha + (1 - delta) * k[:, t]

    # == Generate T instances of lae using this data, one for each t == #
    laes = [LAE(p, k[:, t]) for t in range(T)]

    ygrid = np.linspace(0.01, xmax, 150)
    greys = [str(g) for g in np.linspace(0.0, 0.8, T)]
    greys.reverse()
    for psi, g in zip(laes, greys):
        ax.plot(ygrid, psi(ygrid), color=g, lw=2, alpha=0.6)
    ax.set_xlabel('capital')

09/11/2015 03:55:05 PM INFO: Cell returned
09/11/2015 03:55:05 PM INFO: Running cell:
n = 20
k = 5000
J = 6

theta = 0.9
d = np.sqrt(1 - theta**2) 
delta = theta / d

fig, axes = plt.subplots(J, 1, figsize=(10, 4*J))
initial_conditions = np.linspace(8, 0, J)
X = np.empty((k, n))

for j in range(J):
    
    axes[j].set_ylim(-4, 8)
    title = 'time series from t = ' + str(initial_conditions[j])
    axes[j].set_title(title)
    
    Z = np.random.randn(k, n)
    X[:,0] = initial_conditions[j]
    for t in range(1, n):
        X[:, t] = theta * np.abs(X[:, t-1]) + d * Z[:, t]
    axes[j].boxplot(X)

plt.show()

09/11/2015 03:55:10 PM INFO: Cell returned
09/11/2015 03:55:10 PM INFO: Shutdown kernel
---> END 'statd_solutions.ipynb' <---

---> Executing 'uncertainty_traps_solutions.ipynb' <---
/home/matthewmckay/anaconda/lib/python2.7/site-packages/IPython/nbformat/current.py:19: UserWarning: IPython.nbformat.current is deprecated.

- use IPython.nbformat for read/write/validate public API
- use IPython.nbformat.vX directly to composing notebooks of a particular version

  """)
09/11/2015 03:55:11 PM INFO: Reading notebook uncertainty_traps_solutions.ipynb
09/11/2015 03:55:12 PM INFO: Running cell:
%matplotlib inline

09/11/2015 03:55:13 PM INFO: Cell returned
09/11/2015 03:55:13 PM INFO: Running cell:
from __future__ import division
import matplotlib.pyplot as plt
import numpy as np
import quantecon as qe
import seaborn as sns
import itertools

09/11/2015 03:55:14 PM INFO: Cell returned
09/11/2015 03:55:14 PM INFO: Running cell:
palette = itertools.cycle(sns.color_palette())
econ = qe.models.UncertaintyTrapEcon()
rho, sig_theta, gx = econ.rho, econ.sig_theta, econ.gx # simplify names
g = np.linspace(1e-10, 3, 200)  # gamma grid
fig, ax = plt.subplots(figsize=(9, 9))
ax.plot(g, g, 'k-') # 45 degree line
for M in range(7):
    g_next = 1 / (rho**2 / (g + M * gx) + sig_theta**2)
    label_string = r"$M = {}$".format(M)
    ax.plot(g, g_next, lw=2, label=label_string, color=next(palette))
ax.legend(loc='lower right', fontsize=14)
ax.set_xlabel(r'$\gamma$', fontsize=16)
ax.set_ylabel(r"$\gamma'$", fontsize=16)
ax.grid()
plt.show()

09/11/2015 03:55:16 PM INFO: Cell returned
09/11/2015 03:55:16 PM INFO: Running cell:
sim_length=2000

mu_vec = np.empty(sim_length)
theta_vec = np.empty(sim_length)
gamma_vec = np.empty(sim_length)
X_vec = np.empty(sim_length)
M_vec = np.empty(sim_length)

mu_vec[0] = econ.mu
gamma_vec[0] = econ.gamma
theta_vec[0] = 0

w_shocks = np.random.randn(sim_length)

for t in range(sim_length-1):
    X, M = econ.gen_aggregates()
    X_vec[t] = X
    M_vec[t] = M

    econ.update_beliefs(X, M)
    econ.update_theta(w_shocks[t])

    mu_vec[t+1] = econ.mu
    gamma_vec[t+1] = econ.gamma
    theta_vec[t+1] = econ.theta

# Record final values of aggregates
X, M = econ.gen_aggregates()
X_vec[-1] = X
M_vec[-1] = M

09/11/2015 03:55:16 PM INFO: Cell returned
09/11/2015 03:55:16 PM INFO: Running cell:
fig, ax = plt.subplots(figsize=(9, 6))
ax.plot(range(sim_length), theta_vec, alpha=0.6, lw=2, label=r"$\theta$")
ax.plot(range(sim_length), mu_vec, alpha=0.6, lw=2, label=r"$\mu$")
ax.legend(fontsize=16)
plt.show()

09/11/2015 03:55:17 PM INFO: Cell returned
09/11/2015 03:55:17 PM INFO: Running cell:
fig, axes = plt.subplots(4, 1, figsize=(12, 20))
# Add some spacing
fig.subplots_adjust(hspace=0.3)

series = (theta_vec, mu_vec, gamma_vec, M_vec)
names = r'$\theta$', r'$\mu$', r'$\gamma$', r'$M$'

for ax, vals, name in zip(axes, series, names):
    # determine suitable y limits
    s_max, s_min = max(vals), min(vals)
    s_range = s_max - s_min
    y_max = s_max + s_range * 0.1
    y_min = s_min - s_range * 0.1
    ax.set_ylim(y_min, y_max)
    # Plot series
    ax.plot(range(sim_length), vals, alpha=0.6, lw=2)
    ax.set_title("time series for {}".format(name), fontsize=16)
    ax.grid()

plt.show()

09/11/2015 03:55:19 PM INFO: Cell returned
09/11/2015 03:55:19 PM INFO: Running cell:


09/11/2015 03:55:19 PM INFO: Cell returned
09/11/2015 03:55:19 PM INFO: Shutdown kernel
---> END 'uncertainty_traps_solutions.ipynb' <---

